<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Izg project: Izg project.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Izg project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Izg project. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#zadani">Zadání projektu do předmětu IZG.</a></li>
<li class="level1"><a href="#jakNaTo">Jak na projekt?</a></li>
<li class="level1"><a href="#drawTrianglesImplSec">Implementace funkce drawTrianglesImpl</a><ul><li class="level2"><a href="#VertexAssembly">1. Úkol - naprogramovat vertex assembly jednotku a pouštění vertex shaderu</a><ul><li class="level3"><a href="#vsInvocation">0. Vyvolávání vertex shaderu</a></li>
<li class="level3"><a href="#gl_VertexID">1. Číslování vrcholů</a></li>
<li class="level3"><a href="#gl_VertexIDIndex32">2. Číslování vrcholů s 32bit indexováním.</a></li>
<li class="level3"><a href="#gl_VertexIDIndex16">3. Číslování vrcholů s 16bit indexováním.</a></li>
<li class="level3"><a href="#gl_VertexIDIndex8">4. Číslování vrcholů s 8bit indexováním.</a></li>
<li class="level3"><a href="#VSUniforms">5. Vertex shader by měl dostat uniformy z programu.</a></li>
<li class="level3"><a href="#VertexPuller_Att">6. Vertex Atributy - Vertex Assembly jednotka</a></li>
<li class="level3"><a href="#VertexPuller_Add">7. - 11. oveření správné funkcionality Vertex Assembly jednotky</a></li>
</ul>
</li>
<li class="level2"><a href="#Raster">2. Úkol - naprogramovat Primitive Assembly jednotku, rasterizaci a pouštění fragment shaderu</a><ul><li class="level3"><a href="#PrimitiveAssembly">Primitive Assembly</a></li>
<li class="level3"><a href="#PerspectiveDivision">Perspektivní dělení</a></li>
<li class="level3"><a href="#ViewPortTransformation">Viewport transformace</a></li>
<li class="level3"><a href="#Rasterization">Rasterizace</a></li>
<li class="level3"><a href="#FragmentProcessor">Fragment processor</a></li>
<li class="level3"><a href="#raster_test">12. Ověření, že rasterizace produkuje fragmenty</a></li>
<li class="level3"><a href="#fs_unif_test">13. Ověření, zda fragment shader obdržel uniformní proměnné z programu.</a></li>
<li class="level3"><a href="#pd_test">14. Ověření, zda počítáte perspektivní dělení.</a></li>
<li class="level3"><a href="#fragCoord_test">15. Ověření, zda vyrasterizované fragmenty mají správnou 2D pozici.</a></li>
<li class="level3"><a href="#depthInterp_test">16. Ověření, zda se správně interpoluje hloubka fragmentů.</a></li>
<li class="level3"><a href="#attInterp_test">17., 18. Ověření, zda se správně interpolují vertex attributy.</a></li>
</ul>
</li>
<li class="level2"><a href="#pfo">3. Úkol - naprogramovat per fragment operace a zápis do framebufferu.</a><ul><li class="level3"><a href="#depthTest">Hloubkový test</a></li>
<li class="level3"><a href="#blending">Blending</a></li>
<li class="level3"><a href="#pfo_test">19. - 23. Ověření, zda se správně fungují per fragment operace</a></li>
</ul>
</li>
<li class="level2"><a href="#clip">4. Úkol - naprogramovat ořez trojúhelníků blízkou ořezovou rovinou</a><ul><li class="level3"><a href="#Clipping">Clipping</a></li>
</ul>
</li>
<li class="level2"><a href="#drawModel_fce">5. Úkol - Vykreslování modelů - funkce drawModel</a></li>
<li class="level2"><a href="#drawModel_vs">6. Úkol - Vykreslování modelů - vertex shader drawModel_vertexShader</a></li>
<li class="level2"><a href="#drawModel_fs">7. Úkol - Vykreslování modelů - fragment shader drawMode_fragmentShader</a></li>
</ul>
</li>
<li class="level1"><a href="#rozdeleni">Rozdělení</a></li>
<li class="level1"><a href="#sestaveni">Sestavení</a></li>
<li class="level1"><a href="#spousteni">Spouštění</a></li>
<li class="level1"><a href="#ovladani">Ovládání</a></li>
<li class="level1"><a href="#testovani">Testování</a></li>
<li class="level1"><a href="#odevzdavani">Odevzdávání</a></li>
<li class="level1"><a href="#chyby">Časté chyby, které nedělejte</a></li>
<li class="level1"><a href="#hodnoceni">Hodnocení</a></li>
<li class="level1"><a href="#soutez">Soutěž</a></li>
<li class="level1"><a href="#zaver">Závěrem</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="zadani"></a>
Zadání projektu do předmětu IZG.</h1>
<div class="image">
<img src="vystup.png" alt=""/>
</div>
 <div class="image">
<object type="image/svg+xml" data="teaser.svg" style="pointer-events: none;"></object>
</div>
 <div class="image">
<img src="output.png" alt=""/>
<div class="caption">
Takto by měl vypadat výstup projektu</div></div>
<p>Vašim úkolem je naimplementovat jednoduchou grafickou kartu (gpu). A dále implementovat funkci pro vykreslení modelů. Všechny soubory, které se vás týkají jsou ve složce student/ V souboru <a class="el" href="gpu_8cpp.html" title="This file contains implementation of gpu.">student/gpu.cpp</a> implementujte funkci <a class="el" href="gpu_8cpp.html#a2ad1fed3d7e6cddf0f9a3bd339992f40">drawTrianglesImpl</a> - vykreslování pomocí vámi implementované grafické karty. V souboru <a class="el" href="drawModel_8cpp.html" title="This file contains functions for model rendering.">student/drawModel.cpp</a> implementujete funkce <a class="el" href="drawModel_8hpp.html#ac14f542e0c0210cb47b47abcfa2fc279">drawModel</a>, <a class="el" href="drawModel_8hpp.html#af28c26a23a26d8bb27f8a24833037c3c">drawModel_vertexShader</a> a <a class="el" href="drawModel_8hpp.html#a00d11e84945ed4f7699102c077328bd0">drawModel_fragmentShader</a>. Tyto funkce slouží pro vykreslení načteného souboru s modelem. Kromě toho se ve složce nachází ještě soubor <a class="el" href="fwd_8hpp.html" title="This file contains forward declarations and constants.">student/fwd.hpp</a> - ten obsahuje deklarace struktur a konstant.</p>
<h1><a class="anchor" id="jakNaTo"></a>
Jak na projekt?</h1>
<p>Projekt se může zdát z prvu obrovský s milioném souborů a všelijakých podivností. Tyto "podivnosti" ale nemusíte řešit. Vše, co se vás týká jsou v podstatě 2 soubory do kterých napíšete váš kód a jeden soubor s deklaracemi struktur pro referenci. Projekt okolo těchto souborů vypadá takto z mnoha důvodů (vytvoření okna, načítaní modelů, testování, ...). A není potřeba se jim zabývat (tedy pokud nechcete vidět vnitřnosti a jak celý projekt funguje funguje). Takže jak na to?<br  />
 Vyzkoušejte... </p><div class="fragment"><div class="line"># a mackejte &quot;n&quot; nebo &quot;p&quot; a ovladani mysi</div>
<div class="line">izgProject_windows.exe</div>
<div class="line">izgProject_windows.exe --method 10</div>
<div class="line">izgProject_windows.exe --method 10 --model resources\\models\\konfucius\\scene.gltf</div>
<div class="line">izgProject_windows.exe --method 10 --model resources\\models\\triss\\scene.gltf</div>
<div class="line">izgProject_windows.exe --method 10 --model resources\\models\\lara\\scene.gltf</div>
<div class="line">izgProject_windows.exe --method 10 --model resources\\models\\lara2\\scene.gltf</div>
<div class="line">izgProject_windows.exe --method 10 --model resources\\models\\nyra\\scene.gltf</div>
<div class="line">izgProject_windows.exe --method 10 --model resources\\models\\doom\\scene.gltf</div>
<div class="line">izgProject_windows.exe --method 10 --model resources\\models\\tf2_medic\\scene.gltf</div>
<div class="line">izgProject_windows.exe --method 10 --model resources\\models\\shanghai_city\\scene.gltf</div>
<div class="line"> </div>
<div class="line"># a mackejte &quot;n&quot; nebo &quot;p&quot; a ovladani mysi</div>
<div class="line">./izgProject_linux.bin </div>
<div class="line">./izgProject_linux.bin --method 10</div>
<div class="line">./izgProject_linux.bin --method 10 --model resources/models/konfucius/scene.gltf</div>
<div class="line">./izgProject_linux.bin --method 10 --model resources/models/triss/scene.gltf</div>
<div class="line">./izgProject_linux.bin --method 10 --model resources/models/lara/scene.gltf</div>
<div class="line">./izgProject_linux.bin --method 10 --model resources/models/lara2/scene.gltf</div>
<div class="line">./izgProject_linux.bin --method 10 --model resources/models/nyra/scene.gltf</div>
<div class="line">./izgProject_linux.bin --method 10 --model resources/models/doom/scene.gltf</div>
<div class="line">./izgProject_linux.bin --method 10 --model resources/models/tf2_medic/scene.gltf</div>
<div class="line">./izgProject_linux.bin --method 10 --model resources/models/shanghai_city/scene.gltf</div>
</div><!-- fragment --><p> Jak je to složité? Můj kód pro drawTriangles má ~400 řádků a implementace drawModels a shaderů ~100 řádku. 500 řádků není moc... Není potřeba nic alokovat, pamět je již předchystaná. Takže pokud budete někde volat malloc, new a podobně, zamyslete se. Z C++ se nevyužívá skoro nic (jen union později, vector a knihovna glm, reference). Takže by to mělo jít napsat celkem v pohodě i pro C lidi.</p>
<ol>
<li>
Vyzkoušet si přiložený zkompilovaný referenční projekt izgProject_linux.bin a izgProject_windows.exe. (mačkejte "n" nebo "p", když projekt pustíte, abyste přepínali zobrazované metody). </li>
<li>
<a class="el" href="index.html#sestaveni">Zprovoznit si překlad</a> </li>
<li>
<a class="el" href="index.html#spousteni">Zkusit si projekt pustit a podívat se naparametry příkazové řádky.</a> a <a class="el" href="index.html#ovladani">jak se aplikace ovládá</a> </li>
<li>
V projektu jsou přítomy <a class="el" href="index.html#testovani">akceptační testy</a>, které vám řeknou, jestli jede správným směrem a taky vypisují napovědu. </li>
<li>
Začít implementovat funkci <a class="el" href="gpu_8cpp.html#a2ad1fed3d7e6cddf0f9a3bd339992f40">drawTrianglesImpl</a> a kontrolovat váš postup podle přiložených testů. </li>
<li>
Začít implementovat funkci <a class="el" href="drawModel_8hpp.html#ac14f542e0c0210cb47b47abcfa2fc279">drawModel</a> </li>
<li>
Začít implementovat funkci <a class="el" href="drawModel_8hpp.html#af28c26a23a26d8bb27f8a24833037c3c">drawModel_vertexShader</a> </li>
<li>
Začít implementovat funkci <a class="el" href="drawModel_8hpp.html#a00d11e84945ed4f7699102c077328bd0">drawModel_fragmentShader</a> </li>
<li>
Ověřte si implementaci na merlinovi </li>
<li>
<a class="el" href="index.html#odevzdavani">Odevzdávání</a> Odevzdejte </li>
<li>
??? </li>
<li>
profit </li>
</ol>
<p>Každý úkol má přiřazen akceptační test, takže si můžete snadno ověřit funkčnosti vaší implementace. <br  />
 </p>
<h1><a class="anchor" id="drawTrianglesImplSec"></a>
Implementace funkce drawTrianglesImpl</h1>
<p>Funkce drawTrianglesImpl se nachází v <a class="el" href="gpu_8cpp.html" title="This file contains implementation of gpu.">student/gpu.cpp</a>. Je to funkce, která by měla dokázat vykreslit trojúhelníky. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="gpu_8cpp.html#a2ad1fed3d7e6cddf0f9a3bd339992f40">drawTrianglesImpl</a>(<a class="code" href="structGPUContext.html">GPUContext</a> &amp;ctx,uint32_t nofVertices){</div>
<div class="line">  (void)ctx;</div>
<div class="line">  (void)nofVertices;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Vašim úkolem je ji postupně naprogramovat. Na jeden pokus ji nenaprogramujete, budete ji programovat postupně. Doporučuji si kousky funkce dávat do vlastních podfunkcí, ať máte kód přehledný.</p>
<p>První věc, na co se asi ptáte: odkud bere trojúhelníky a kam je kreslí? Funkce bere 2 parametry: <a class="el" href="structGPUContext.html" title="[Frame]">GPUContext</a> ctx, uint32_t nofVertices. nofVertices je počet vrcholů trojúhelníků, které by ta funkce měla vykreslit. Tzn. 3 pro 1 trojúhelník, 12 pro 4 trojúhelníky, apod. Zajímavější parametr je ctx - <a class="el" href="structGPUContext.html" title="[Frame]">GPUContext</a>.<br  />
 </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structGPUContext.html">GPUContext</a>{</div>
<div class="line">  <a class="code" href="structVertexArray.html">VertexArray</a> <a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>                    ; </div>
<div class="line">  <a class="code" href="structProgram.html">Program</a>     <a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>                    ; </div>
<div class="line">  <a class="code" href="structFrame.html">Frame</a>       <a class="code" href="structGPUContext.html#ab632150244bd53d4ed01fab7fd93be51">frame</a>                  ; </div>
<div class="line">};</div>
</div><!-- fragment --><p>Co je to <a class="el" href="structGPUContext.html" title="[Frame]">GPUContext</a>? Tak je v projektu pojmenovaný stav virtuální grafické karty. Je to struktura, která obsahuje všechno nastavení, které je potřebné pro kreslení. Obsahuje plátno, kam se má kreslit (<a class="el" href="structFrame.html" title="[Program]">Frame</a>), obsahuje data, ve kterých jsou uloženy trojúhelníky (<a class="el" href="structVertexArray.html" title="[VertexAttrib]">VertexArray</a>), obsahuje program (<a class="el" href="structProgram.html" title="[VertexArray]">Program</a>, vertex shader, fragment shader), který dané trojúhelníky vykreslí.<br  />
 </p><div class="image">
<object type="image/svg+xml" data="ctx_overview.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Přehled toho, co je v kontextu. VertexArray je něco jako vstup pro vykreslování, jsou v něm 'zakódované' trojúhelníky. Frame je výstupní obrázek, který se kreslí. A program je společně s vykreslovacím řetězcem transformace vstupu na výstup.</div></div>
<p> Takže se jedná o stav, v jakém se grafická karta nachází před spuštěním kreslení. Funkce drawTrianglesImpl (dále jen drawTriangles) by se měla podívat do kontextu grafické karty a změnit jej.<br  />
 Proces kreslení na grafické kartě probíhá v zobrazovacím řetězci.<br  />
 </p><h3>gpu Grafická karta</h3>
<div class="image">
<object type="image/svg+xml" data="pipeline_overview.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Grafická karta je složena z paměti a zobrazovacího řetězce. Z paměti tečou vrcholy a trojúhelníky, které jsou vyrasterizovány zpět do paměti.</div></div>
 <h3>Zobrazovací řetězec</h3>
<p>Zobrazovací řetězec je složen ze tří částí: vektorová část, rasterizace, rastrová část. </p><div class="image">
<object type="image/svg+xml" data="pipeline_vector_raster.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Zobrazovací řetězec je složen z vektorové a rastrové části mezi kterými leží rasterizace.</div></div>
 <h3>Vektorová část zobrazovací řetězec</h3>
<p>Cílem vektorové části je zpravovávat vektorovou grafiku: body, trojúhelníky. Většinou se tím myslí: čtení z paměti a sestavení vrcholů, vyvolání vertex shaderu nad každým vrcholem, sestavení trojúhelníků, ořez, perspektivní dělení a připravení pro rasterizaci (viewport transformace). Rasterizace rasterizuje připravené trojúhelníky a produkuje fragmenty (čtvercové úlomky trojúhelníku, které se nakonec zapíšou do framebufferu). Cílem rastrové části je obarvit tyto fragmenty pomocí fragment shaderu, odfiltrovat fragmenty, které jsou příliš daleko (depth test) a smíchat je s framebufferem (blending).<br  />
 Ze začátku implementace funkce drawTriangles se budete zabývat pouze vektorovou částí - a to částí před vertex shaderem (včetně). </p><div class="image">
<object type="image/svg+xml" data="pipeline_vector.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Vektorová část je složena z vertex assembly jednotky, vertex processoru a části za vertex shaderem.</div></div>
<p> Vertex assembly jednota se stará o sestavování vrcholů. Vertex processor tyto vrcholy "prožene" uživatelem specifikovaným vertex shaderem. Část za vertex shaderem se stará o sestavení trojúhelníku, jeho ořezu a ztransformování pro rasterizaci.<br  />
 </p><h3>Vertex Processor</h3>
<p>Úkolem vertex processoru je pouštět uživatelem specifikovaný vertex shader. Obvykle provádí transformace vrcholů pomocí transformačních matic. Vertex processor vykonává shader (kus programu), kterému se říká vertex shader. Vstupem vertex shaderu je vrchol <a class="el" href="structInVertex.html">InVertex</a>, výstupem je vrchol <a class="el" href="structOutVertex.html">OutVertex</a>. Dalším (konstatním) vstupem vertex shaderu jsou uniformní proměnné <a class="el" href="structUniforms.html">Uniforms</a>, které jsou uložené v rámci shader programu. Pokud se uživatel rozhodne vykreslit 5 trojúhelníků je vertex shader spuštěn \( 5 \cdot 3 = 15 \). Jednotlivé spuštění (invokace) vertex shaderu vyžadují nové vstupní vrcholy a produkují nové výstupní vrcholy. To ve výsledku znamená, že se pro každou invokaci vertex shaderu spustí Vertex Assembly jednotka, která sestaví vstupní vrchol. </p><div class="image">
<object type="image/svg+xml" data="vertexShader.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Vizualizace vstupů a výstupů vertex procesoru. Ve vertex procesoru běží vertex shader, který obdrží vstupní vrchol, vyprodukuje výstupní vrchol a obdrží vstupní konstanty (uniformní proměnné).</div></div>
<h2><a class="anchor" id="VertexAssembly"></a>
1. Úkol - naprogramovat vertex assembly jednotku a pouštění vertex shaderu</h2>
<p>První část, kdy se konečně dostanete k programování je vertex assembly jednota a pouštění vertex shaderu. Vážou se k ní testy 0. - 11.<br  />
 </p><div class="fragment"><div class="line">izgProject -c --test 11 --up-to-test</div>
</div><!-- fragment --><p> Pseudokód může vypadat nějak takto: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> runVertexAssembly(){</div>
<div class="line">  computeVertexID();</div>
<div class="line">  readAttributes();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="gpu_8hpp.html#ab74fb851bb0923d1cc071b461939cc3c">drawTriangles</a>(<a class="code" href="structGPUContext.html">GPUContext</a>&amp;ctx,uint32_t nofVertices){</div>
<div class="line">  <span class="keywordflow">for</span>(every vertex v){</div>
<div class="line">    <a class="code" href="structInVertex.html">InVertex</a> inVertex;</div>
<div class="line">    <a class="code" href="structOutVertex.html">OutVertex</a> outVertex;</div>
<div class="line">    runVertexAssembly(inVertex,ctx.<a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>,v);</div>
<div class="line">    prg.vertexShader(outVertex,inVertex,ctx.<a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>.<a class="code" href="structProgram.html#a857fb2633d95dd4381cd06a24130d1ef">uniforms</a>);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="vsInvocation"></a>
0. Vyvolávání vertex shaderu</h3>
<div class="fragment"><div class="line">izgProject -c --test 0</div>
</div><!-- fragment --><p> V tomto testu musíte zavolat vertex shader tolikrát, kolik je zadáno funkci drawTriangles. Vertex shader se nachází ve struktuře <a class="el" href="structProgram.html" title="[VertexArray]">Program</a> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structProgram.html">Program</a>{</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#af647cdb302d7e978c6a0da41a0a92725">VertexShader</a>   <a class="code" href="structProgram.html#a2bcea678985527f04a87be358ff1f78b">vertexShader</a>   = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a52f1704ae0b129e49fe1902e05319ad6">FragmentShader</a> <a class="code" href="structProgram.html#a5faf623d0af27d6000ebcacafecf2eb5">fragmentShader</a> = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structUniforms.html">Uniforms</a>       <a class="code" href="structProgram.html#a857fb2633d95dd4381cd06a24130d1ef">uniforms</a>                ; </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a349a9cde14be8097df865ba0469c0ab2">AttributeType</a>  <a class="code" href="structProgram.html#a5b48bbf6bc459552b066757369a0f86d">vs2fs</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>] = {<a class="code" href="fwd_8hpp.html#a349a9cde14be8097df865ba0469c0ab2aba2b45bdc11e2a4a6e86aab2ac693cbb">AttributeType::EMPTY</a>}; </div>
<div class="line">};</div>
</div><!-- fragment --><p>A program se nachází se struktuře <a class="el" href="structGPUContext.html" title="[Frame]">GPUContext</a> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structGPUContext.html">GPUContext</a>{</div>
<div class="line">  <a class="code" href="structVertexArray.html">VertexArray</a> <a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>                    ; </div>
<div class="line">  <a class="code" href="structProgram.html">Program</a>     <a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>                    ; </div>
<div class="line">  <a class="code" href="structFrame.html">Frame</a>       <a class="code" href="structGPUContext.html#ab632150244bd53d4ed01fab7fd93be51">frame</a>                  ; </div>
<div class="line">};</div>
</div><!-- fragment --><p>Což je parameter funkce <a class="el" href="gpu_8cpp.html#a2ad1fed3d7e6cddf0f9a3bd339992f40">drawTrianglesImpl</a>, kterou implementujete v souboru <a class="el" href="gpu_8cpp.html">student/gpu.cpp</a> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="gpu_8cpp.html#a2ad1fed3d7e6cddf0f9a3bd339992f40">drawTrianglesImpl</a>(<a class="code" href="structGPUContext.html">GPUContext</a> &amp;ctx,uint32_t nofVertices){</div>
<div class="line">  (void)ctx;</div>
<div class="line">  (void)nofVertices;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Vertex shader je v podobě ukazatele na funkci. Na normální GPU se jedná o program (třeba v GLSL), který se kompiluje. V projektu je to normální C/C++ funkce, která je uložena v ukazateli na funkci. Vertex shader bere 3 parametry </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="fwd_8hpp.html#af647cdb302d7e978c6a0da41a0a92725">VertexShader</a>   = void(*)(</div>
<div class="line">    <a class="code" href="structOutVertex.html">OutVertex</a>      &amp;outVertex,</div>
<div class="line">    <a class="code" href="structInVertex.html">InVertex</a>  <span class="keyword">const</span>&amp;inVertex ,</div>
<div class="line">    <a class="code" href="structUniforms.html">Uniforms</a>  <span class="keyword">const</span>&amp;uniforms );</div>
</div><!-- fragment --><p>V tomto testu se neřeší, co dostane, ale měl by něco dostat. </p>
<h3><a class="anchor" id="gl_VertexID"></a>
1. Číslování vrcholů</h3>
<div class="fragment"><div class="line">izgProject -c --test 1</div>
</div><!-- fragment --><p> V tomto testu musíte správně číslovat vstupní vrcholy do vertex shaderu. Zatím bude stačit jim dát pořadové číslo. Vstupní vrchol se nachází ve struktuře <a class="el" href="structInVertex.html" title="[Attribute]">InVertex</a> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structInVertex.html">InVertex</a>{</div>
<div class="line">  <a class="code" href="unionAttribute.html">Attribute</a> <a class="code" href="structInVertex.html#a4fc269d49110daa41aedf9b8f313f0ca">attributes</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>]    ; </div>
<div class="line">  uint32_t  <a class="code" href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">gl_VertexID</a>               = 0; </div>
<div class="line">};</div>
</div><!-- fragment --><p>ve které je položka <a class="el" href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">InVertex::gl_VertexID</a>, což je číslo vrcholu, kterou musíte správně nastavit. </p>
<h3><a class="anchor" id="gl_VertexIDIndex32"></a>
2. Číslování vrcholů s 32bit indexováním.</h3>
<div class="fragment"><div class="line">izgProject -c --test 2</div>
</div><!-- fragment --><p> V tomto testu musíte správně číslovat vstupní vrcholy, když je zapnuté indexování.<br  />
 <b>Indexované kreslení</b> je způsob snížení redundance dat s využitím indexů na vrcholy. U neindexovaného kreslení je číslo vrcholu <a class="el" href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">InVertex::gl_VertexID</a> rovno číslu invokace vertex shaderu. U indexovaného kreslení je číslo vrcholu <a class="el" href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">InVertex::gl_VertexID</a> rovno hodnodě z indexačního bufferu. Hodnota z indexačního bufferu je vybrána číslem invokace vertex shaderu. <br  />
 Indexační buffer může mít růzou velikost indexu - 8bit, 16bit a 32bit: </p><div class="fragment"><div class="line"><span class="keyword">enum class</span> <a class="code" href="fwd_8hpp.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839">IndexType</a>{</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839aecfc091ed2a607335524c8389cfa41b5">UINT8</a>  = 1, </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839a48d8f1a723d44ff4a87db1bb6c551c62">UINT16</a> = 2, </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839a17266551181f69a1b4a3ad5c9e270afc">UINT32</a> = 4, </div>
<div class="line">};</div>
</div><!-- fragment --><p>Pokud je zapnuto indexování, pak je číslo vrcholu dáno položkou v indexačním bufferu, kde je položka (index) v bufferu vybrána na základě čísla invokace vertex shaderu. </p><div class="image">
<object type="image/svg+xml" data="drawElements.svg" style="pointer-events: none;"></object>
<div class="caption">
Neindexované a indexované kreslení.</div></div>
<p> Jestli je indexované kreslení zapnuto nebo vypnuto zjistítě ve struktuře <a class="el" href="structVertexArray.html" title="[VertexAttrib]">VertexArray</a> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structVertexArray.html">VertexArray</a>{</div>
<div class="line">  <a class="code" href="structVertexAttrib.html">VertexAttrib</a> <a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>];     </div>
<div class="line">  <span class="keywordtype">void</span> <span class="keyword">const</span>*  <a class="code" href="structVertexArray.html#ae7da1c1e5a13ae73e038d87bd0359ce6">indexBuffer</a> = <span class="keyword">nullptr</span>;           </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839">IndexType</a>    <a class="code" href="structVertexArray.html#a7822420a93f7334ffdb1a0992de59ae3">indexType</a>   = <a class="code" href="fwd_8hpp.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839a17266551181f69a1b4a3ad5c9e270afc">IndexType::UINT32</a>; </div>
<div class="line">};</div>
</div><!-- fragment --><p>která je uložena ve struktuře <a class="el" href="structGPUContext.html" title="[Frame]">GPUContext</a> v parametru ctx. <a class="el" href="structVertexArray.html#ae7da1c1e5a13ae73e038d87bd0359ce6">VertexArray::indexBuffer</a> je ukazatel na pamět indexů. Pokud je nastavený na nullptr, není indexování zapnuto. Pokud ukazuje na nějakou adresu, je indexování zapnuto a typ indexu je uložen v položce <a class="el" href="structVertexArray.html#a7822420a93f7334ffdb1a0992de59ae3">VertexArray::indexType</a>. <a class="el" href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">InVertex::gl_VertexID</a> by měl být nastaven na hodnotu z indexačního bufferu. Pozor, index může mít různou velikost. Může být 32bit, 16bit, 8bit. </p>
<h3><a class="anchor" id="gl_VertexIDIndex16"></a>
3. Číslování vrcholů s 16bit indexováním.</h3>
<div class="fragment"><div class="line">izgProject -c --test 3</div>
</div><!-- fragment --><p> Podobné jako u <a class="el" href="index.html#gl_VertexIDIndex32">32bit indexování...</a> </p>
<h3><a class="anchor" id="gl_VertexIDIndex8"></a>
4. Číslování vrcholů s 8bit indexováním.</h3>
<div class="fragment"><div class="line">izgProject -c --test 4</div>
</div><!-- fragment --><p> Podobné jako u <a class="el" href="index.html#gl_VertexIDIndex32">32bit indexování...</a> </p>
<h3><a class="anchor" id="VSUniforms"></a>
5. Vertex shader by měl dostat uniformy z programu.</h3>
<div class="fragment"><div class="line">izgProject -c --test 5</div>
</div><!-- fragment --><p> Uniformní proměnné jsou konstanty z pohledu vertex shaderu. Jsou to data, která uživatel dodat svému vertex shaderu. Obvykle jsou to matice, pozice světla, barva materiálu... Jsou uloženy v položce prg struktury <a class="el" href="structGPUContext.html" title="[Frame]">GPUContext</a>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structGPUContext.html">GPUContext</a>{</div>
<div class="line">  <a class="code" href="structVertexArray.html">VertexArray</a> <a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>                    ; </div>
<div class="line">  <a class="code" href="structProgram.html">Program</a>     <a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>                    ; </div>
<div class="line">  <a class="code" href="structFrame.html">Frame</a>       <a class="code" href="structGPUContext.html#ab632150244bd53d4ed01fab7fd93be51">frame</a>                  ; </div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structUniforms.html">Uniforms</a>{</div>
<div class="line">  <a class="code" href="unionUniform.html">Uniform</a> <a class="code" href="structUniforms.html#ac1130b74094bf1d7eaa9e18b332deff9">uniform</a> [<a class="code" href="fwd_8hpp.html#a7d487fa31fd72d7d5b6d952880a2f137">maxUniforms</a>];</div>
<div class="line">  <a class="code" href="structTexture.html">Texture</a> <a class="code" href="structUniforms.html#a0be49c6c3e3b457991afe344138a3103">textures</a>[<a class="code" href="fwd_8hpp.html#a4c2eb5328acb9e61d6477a9bdba62dac">maxTextures</a>];</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">union </span><a class="code" href="unionUniform.html">Uniform</a>{</div>
<div class="line">  <a class="code" href="unionUniform.html">Uniform</a>(){}</div>
<div class="line">  <span class="keywordtype">float</span>     <a class="code" href="unionUniform.html#a2714f4ff3e6703bccdac2c92dcad3b25">v1</a>; </div>
<div class="line">  glm::vec2 <a class="code" href="unionUniform.html#ae497d8a71600e5eb222cbcf8ad71788f">v2</a>; </div>
<div class="line">  glm::vec3 <a class="code" href="unionUniform.html#a70392e438c775c6213e6c2dec76b29c4">v3</a>; </div>
<div class="line">  glm::vec4 <a class="code" href="unionUniform.html#ad2afb58e290202cd23e444440e1b1f07">v4</a>; </div>
<div class="line">  glm::mat4 <a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a> = glm::mat4(1.f); </div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="VertexPuller_Att"></a>
6. Vertex Atributy - Vertex Assembly jednotka</h3>
<div class="fragment"><div class="line">izgProject -c --test 6</div>
</div><!-- fragment --><p> V tomto testu musíte naprogramovat funkcionalitu Vertex Assembly jednotky.<br  />
 <b>Vertex Assembly</b> (nebo taky Vertex Puller, Vertex Specification, ...) je zařízení na grafické kartě, které se stará o sestavení vrcholů. </p><div class="image">
<object type="image/svg+xml" data="vertex.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Vrchol je struktura data. Ve struktuře jsou vertex attributy. Tyto mívají uživatelem specifikovaný význam (třeba pozice, normála, ...). Vertex Assembly sestavuje InVertex, který je poslán jako vstup do vertex shaderu. OutVertex je výstup vertex shaderu.</div></div>
 <div class="image">
<object type="image/svg+xml" data="vertexInOut.svg" width="400" style="pointer-events: none;"></object>
<div class="caption">
Jsou dva typy vrcholů. Ty, které sestavuje jednotka Vertex Assembly a vstupují do vertex shaderu. A ty, které jsou výstupem vertex shaderu.</div></div>
<p> Vrchol (<a class="el" href="structInVertex.html">InVertex</a>) je složen z <a class="el" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a> vertex attributů, každý může být různého typu (<a class="el" href="fwd_8hpp.html#a349a9cde14be8097df865ba0469c0ab2">AttributeType</a> (float, vec2, vec3, vec4) a čísla vrcholu <a class="el" href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">InVertex::gl_VertexID</a>.<br  />
 Struckura <a class="el" href="structInVertex.html">InVertex</a> vypadá takto: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structInVertex.html">InVertex</a>{</div>
<div class="line">  <a class="code" href="unionAttribute.html">Attribute</a> <a class="code" href="structInVertex.html#a4fc269d49110daa41aedf9b8f313f0ca">attributes</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>]    ; </div>
<div class="line">  uint32_t  <a class="code" href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">gl_VertexID</a>               = 0; </div>
<div class="line">};</div>
</div><!-- fragment --><p>Struktura <a class="el" href="structOutVertex.html">OutVertex</a> vypadá takto: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structOutVertex.html">OutVertex</a>{</div>
<div class="line">  <a class="code" href="unionAttribute.html">Attribute</a> <a class="code" href="structOutVertex.html#ad1d48203a36e3ee510841f25a5bc068e">attributes</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>]                     ; </div>
<div class="line">  glm::vec4 <a class="code" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a>               = glm::vec4(0,0,0,1); </div>
<div class="line">};</div>
</div><!-- fragment --><p>Obě struktury obsahují vertex atributy <a class="el" href="unionAttribute.html">Attribute</a> </p><div class="fragment"><div class="line"><span class="keyword">union </span><a class="code" href="unionAttribute.html">Attribute</a>{</div>
<div class="line">  <a class="code" href="unionAttribute.html">Attribute</a>(){}</div>
<div class="line">  <span class="keywordtype">float</span>     <a class="code" href="unionAttribute.html#a2a9e03282539207b21a9b61596e6b72c">v1</a>; </div>
<div class="line">  glm::vec2 <a class="code" href="unionAttribute.html#aa240c263ec02c39b48d662a1c598e1fc">v2</a>; </div>
<div class="line">  glm::vec3 <a class="code" href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">v3</a>; </div>
<div class="line">  glm::vec4 <a class="code" href="unionAttribute.html#ac47131c7c30814e28f0c4662a4ed2737">v4</a> = glm::vec4(1.f); </div>
<div class="line">};</div>
</div><!-- fragment --><p>Vertex Assembly jednotka se řídí podle nastavení <a class="el" href="structVertexArray.html" title="[VertexAttrib]">VertexArray</a> struktury. </p><div class="image">
<object type="image/svg+xml" data="pullerSettings.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Nastavení pro Vertex Assembly jednotku - VertexArray.</div></div>
<p> Toto nastavení je uloženo ve struktuře <a class="el" href="structVertexArray.html" title="[VertexAttrib]">VertexArray</a>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structVertexArray.html">VertexArray</a>{</div>
<div class="line">  <a class="code" href="structVertexAttrib.html">VertexAttrib</a> <a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>];     </div>
<div class="line">  <span class="keywordtype">void</span> <span class="keyword">const</span>*  <a class="code" href="structVertexArray.html#ae7da1c1e5a13ae73e038d87bd0359ce6">indexBuffer</a> = <span class="keyword">nullptr</span>;           </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839">IndexType</a>    <a class="code" href="structVertexArray.html#a7822420a93f7334ffdb1a0992de59ae3">indexType</a>   = <a class="code" href="fwd_8hpp.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839a17266551181f69a1b4a3ad5c9e270afc">IndexType::UINT32</a>; </div>
<div class="line">};</div>
</div><!-- fragment --><p>Je složeno z nastavení pro indexování a nastavení pro vertex attributy. <a class="el" href="structVertexAttrib.html" title="[FragmentShader]">VertexAttrib</a> je struktura obsahují nastavení, jak číst jeden Vertex Attribut. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structVertexAttrib.html">VertexAttrib</a>{</div>
<div class="line">  <span class="keywordtype">void</span> <span class="keyword">const</span>*   <a class="code" href="structVertexAttrib.html#a8a69adafb547d0991fa7031771b5771d">bufferData</a> = nullptr             ;</div>
<div class="line">  uint64_t      <a class="code" href="structVertexAttrib.html#aef250d71bce43e96a6efb9180f24d079">stride</a>     = 0                   ;</div>
<div class="line">  uint64_t      <a class="code" href="structVertexAttrib.html#a58f3129f893d0ce72ec7d364fef21840">offset</a>     = 0                   ;</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a349a9cde14be8097df865ba0469c0ab2">AttributeType</a> <a class="code" href="structVertexAttrib.html#a0b722b51b4528b50603e99722329d41a">type</a>       = <a class="code" href="fwd_8hpp.html#a349a9cde14be8097df865ba0469c0ab2aba2b45bdc11e2a4a6e86aab2ac693cbb">AttributeType::EMPTY</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Vertex Assembly jednotka je složena z <a class="el" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a> čtecích hlav, které sestavují jednotlivé vertex attributy. <a class="el" href="structInVertex.html">InVertex</a> je složen z <a class="el" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a> atributů, každý odpovídá jedné čtecí hlavě z Vertex Assembly jednotky. Čtecí hlava obsahuje nastavení - offset, stride, type a buffer. Pokud je čtecí hlava povolena (typ není empty), měla by zkopírovat data (o velikosti vertex atributu) z bufferu od daného offsetu, s krokem stride. Všechny velikosti jsou v bajtech. Krok se použije při čtení různých vrcholů: atributy by měly být čteny z adresy: buf_ptr + offset + stride*gl_VertexID <br  />
 Na dalších dvou obrázcích je příklad stavu Vertex Assembly jednotky ve dvou (0. a 1.) invokaci vertex shaderu. </p><div class="image">
<object type="image/svg+xml" data="puller0.svg" style="pointer-events: none;"></object>
<div class="caption">
příklad vertex pulleru při 0. invokací vertex shaderu. Vertex je složen z 3 vertex atributů (coord, normal, position). Čtecí hlavy začínají na daných offsetech a v daných bufferech.</div></div>
 <div class="image">
<object type="image/svg+xml" data="puller1.svg" style="pointer-events: none;"></object>
<div class="caption">
příklad vertex pulleru při 1. invokací vertex shaderu. Čtecí hlavy se posunuly o krok (stride).</div></div>
<h3><a class="anchor" id="VertexPuller_Add"></a>
7. - 11. oveření správné funkcionality Vertex Assembly jednotky</h3>
<div class="fragment"><div class="line">izgProject -c --test 7</div>
<div class="line">izgProject -c --test 8</div>
<div class="line">izgProject -c --test 9</div>
<div class="line">izgProject -c --test 10</div>
<div class="line">izgProject -c --test 11</div>
</div><!-- fragment --><p> Cílem těchto testů je otestovat, jestli jste Vertex Assembly jednotku naprogramovali správně. Po těchto úkolech byste měli mít hotovotou část před vertex shaderem.</p>
<h2><a class="anchor" id="Raster"></a>
2. Úkol - naprogramovat Primitive Assembly jednotku, rasterizaci a pouštění fragment shaderu</h2>
<p>V tomto úkolu je potřeba rozšířit funkcionalitu funkce drawTriangles o schopnosti rasterizace. Cílem je naprogramovat části zobrazovacího řetězce, které jsou za vertex shaderem po rasterizaci a pouštění fragment shaderu (včetně).<br  />
 Jedná se o testy 12. - 18.<br  />
 Pseudokód může po upravení vypadat nějak takto: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> runVertexAssembly(){</div>
<div class="line">  computeVertexID();</div>
<div class="line">  readAttributes();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> runPrimitiveAssembly(primitive,<a class="code" href="structVertexArray.html">VertexArray</a> vao,t,<a class="code" href="structProgram.html">Program</a> prg){</div>
<div class="line">  <span class="keywordflow">for</span>(every vertex v in triangle){</div>
<div class="line">    <a class="code" href="structInVertex.html">InVertex</a> inVertex;</div>
<div class="line">    runVertexAssembly(inVertex,vao,t+v);</div>
<div class="line">    prg.<a class="code" href="structProgram.html#a2bcea678985527f04a87be358ff1f78b">vertexShader</a>(primitive.vertex,inVertex,prg.<a class="code" href="structProgram.html#a857fb2633d95dd4381cd06a24130d1ef">uniforms</a>);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> rasterizeTriangle(frame,primitive,prg){</div>
<div class="line">  <span class="keywordflow">for</span>(pixels in frame){</div>
<div class="line">    <span class="keywordflow">if</span>(pixels in primitive){</div>
<div class="line">      <a class="code" href="structInFragment.html">InFragment</a> inFragment;</div>
<div class="line">      createFragment(inFragment,primitive,barycentrics,pixelCoord,prg);</div>
<div class="line">      <a class="code" href="structOutFragment.html">OutFragment</a> outFragment;</div>
<div class="line">      prg.<a class="code" href="structProgram.html#a5faf623d0af27d6000ebcacafecf2eb5">fragmentShader</a>(outFragment,inFragment,uniforms);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="gpu_8hpp.html#ab74fb851bb0923d1cc071b461939cc3c">drawTriangles</a>(<a class="code" href="structGPUContext.html">GPUContext</a>&amp;ctx,uint32_t nofVertices){</div>
<div class="line">  <span class="keywordflow">for</span>(every triangle t){</div>
<div class="line">    Primitive primitive;</div>
<div class="line">    runPrimitiveAssembly(primitive,ctx.<a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>,t,ctx.<a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>)</div>
<div class="line"> </div>
<div class="line">    runPerspectiveDivision(primitive)</div>
<div class="line">    runViewportTransformation(primitive,ctx.frame)</div>
<div class="line">    rasterizeTriangle(ctx.frame,primitive,ctx.prg);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Vertex Assembly jednotka chrlí vrcholy a vertex shader je zpracovává, transformuje. Je na čase z nich sestavit trojúhelníky a připravit je pro rasterizaci. Část za vertex shaderem je složena z několika částí. </p><div class="image">
<object type="image/svg+xml" data="pipeline_after_vs.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Část za vertex shaderem je složena z několika jednotek. Je to jednotka sestavení primitiv (trojúhelníků), ořez (ten teď dělat nebudete), perspektivní dělení, viewport transformace. Po vektorové části následuje rasterizace a fragment shader</div></div>
 <h3><a class="anchor" id="PrimitiveAssembly"></a>
Primitive Assembly</h3>
<p>Primitive Assembly je jednotka, která sestavuje trojúhelníky (mimo jiné). Trojúhelníku, úsečce, bodu se hromadně říká primitivum. V tomto projektu se používají pouze trojúhelníky. Primitive Assembly jednotka si počká na 3 po sobě jdoucí <a class="el" href="structOutVertex.html">výstupní vrcholy</a> z vertex shaderu a sestaví trojúhelník (struktura, která by měla obsahovat 3 výstupní vrcholy). Lze na to také nahlížet tak, že primitive assembly jednotka dostane příkaz vykreslit třeba 4 trojúhelníky. Jednotka tak spustí vertex shader 12x, který takto spustí 12x vertex assembly jednotku.</p>
<div class="image">
<object type="image/svg+xml" data="PrimitiveAssembly.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Vizualizace funkce primitive assembly jednotky. Primitive assembly jednotka sestaví trojúhelník ze 3 po sobě jdoucích výstupních vrcholů z vertex shaderu.</div></div>
<h3><a class="anchor" id="PerspectiveDivision"></a>
Perspektivní dělení</h3>
<p>Perspektivní dělení následuje za clippingem (ten bude až později, teď není potřeba) a provádí převod z homogenních souřadnic na kartézské pomocí dělení w. </p><div class="image">
<object type="image/svg+xml" data="PerspectiveDivision.svg" width="500" style="pointer-events: none;"></object>
<div class="caption">
Perspektivní dělení. Převod z clip-space do NDC (normalized device coordinates). Dělí se pomocí w. Při tomto dělení vzniknou normalizované souřadnice x,y a normalizovaná hloubka.</div></div>
<h3><a class="anchor" id="ViewPortTransformation"></a>
Viewport transformace</h3>
<p>Viewport transformace provádí převod NDC (rozsah -1, +1) na rozlišení okna, aby se mohla provést rasterizace. </p><div class="image">
<object type="image/svg+xml" data="ViewportTransformation.svg" width="500" style="pointer-events: none;"></object>
<div class="caption">
Vizualizace viewport transformace. Trojúhelníky jsou roztaženy na rozlišení obrazovky [width,height] do screen-space. Hloubka zůstane zachována v komponentě z.</div></div>
<h3><a class="anchor" id="Rasterization"></a>
Rasterizace</h3>
<p>Rasterizace rasterizuje trojúhelník ve screen-space. Rasterizace produkuje fragmenty v případě, že <b>střed</b> pixelu leží uvnitř trojúhelníka. </p><div class="image">
<object type="image/svg+xml" data="rasterization.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Rasterizace produkuje fragmenty. Pokud střed pixelu leží uvnitř trojúhelníka, vytvoří se fragment.</div></div>
<h3><a class="anchor" id="FragmentProcessor"></a>
Fragment processor</h3>
<p>Fragment processor spouští fragment shader nad každým fragmentem. Data pro fragment shader jsou uložena ve struktuře <a class="el" href="structInFragment.html">InFragment</a>. Výstup fragment shaderu je výstupní fragment <a class="el" href="structOutFragment.html">OutFragment</a> - barva. Další (konstantní) vstup fragment shaderu jsou uniformní proměnné. </p><div class="image">
<object type="image/svg+xml" data="FragmentShader.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Vizualizace vstupů a výstupů fragment shaderu. Fragment Shader se pouší nad každým vyrasterizovaným fragmentem.</div></div>
<h3><a class="anchor" id="raster_test"></a>
12. Ověření, že rasterizace produkuje fragmenty</h3>
<p>V tomto úkolu budete muset naprogramovat rasterizaci. Neobejdete se bez viewport transformace, rasterizace a zavolání fragment shaderu nad každným fragmentem. Tento test spočívá ve zkoušení vyrasterizování několika různých trojúhelníků a počítání, kolik se vyrasterizovalo fragmentů.<br  />
 Testy pustíte: </p><div class="fragment"><div class="line">izgProject -c --test 12</div>
</div><!-- fragment --><h3><a class="anchor" id="fs_unif_test"></a>
13. Ověření, zda fragment shader obdržel uniformní proměnné z programu.</h3>
<p>Tento test ověřuje, že posíláte fragment shaderu uniformní proměnné z programu. </p><div class="fragment"><div class="line">izgProject -c --test 13</div>
</div><!-- fragment --><h3><a class="anchor" id="pd_test"></a>
14. Ověření, zda počítáte perspektivní dělení.</h3>
<p>Tento test ověřuje, zda provádíte perspektivní dělení. </p><div class="fragment"><div class="line">izgProject -c --test 14</div>
</div><!-- fragment --><h3><a class="anchor" id="fragCoord_test"></a>
15. Ověření, zda vyrasterizované fragmenty mají správnou 2D pozici.</h3>
<p>Tento test ověřuje, zda vyrasterizované fragmenty mají správnou 2D pozici <a class="el" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">InFragment::gl_FragCoord</a>. </p><div class="fragment"><div class="line">izgProject -c --test 15</div>
</div><!-- fragment --><p> Fragmenty mají souřadnice středů pixelů, kterým náleží. Tzn. fragment pro levý dolní pixel [0,0] má souřadnice gl_FragCoord.xy = [0.5,0.5]</p>
<h3><a class="anchor" id="depthInterp_test"></a>
16. Ověření, zda se správně interpoluje hloubka fragmentů.</h3>
<p>Tento test ověřuje, zda vyrasterizované fragmenty mají správně interpolovanou hloubku. </p><div class="fragment"><div class="line">izgProject -c --test 16</div>
</div><!-- fragment --><p> Hloubka fragmentu je komponentě "z" položky <a class="el" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">InFragment::gl_FragCoord</a>. Pro její interpolaci potřebujete hloubky vrcholů trojúhelníka a barycentrické souřadnice fragmentu ve 2D.<br  />
 Hloubky vrcholů najdete ve "z" komponentě položky <a class="el" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">OutVertex::gl_Position</a> gl_Position.z </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structOutVertex.html">OutVertex</a>{</div>
<div class="line">  <a class="code" href="unionAttribute.html">Attribute</a> <a class="code" href="structOutVertex.html#ad1d48203a36e3ee510841f25a5bc068e">attributes</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>]                     ; </div>
<div class="line">  glm::vec4 <a class="code" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a>               = glm::vec4(0,0,0,1); </div>
<div class="line">};</div>
</div><!-- fragment --><p>Hloubku zapisujte do komponenty "z" položky <a class="el" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">InFragment::gl_FragCoord</a> gl_FragCoord.z </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structInFragment.html">InFragment</a>{</div>
<div class="line">  <a class="code" href="unionAttribute.html">Attribute</a> <a class="code" href="structInFragment.html#af9cd9e9a684a1c454d52d7e191564be1">attributes</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>]               ; </div>
<div class="line">  glm::vec4 <a class="code" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">gl_FragCoord</a>              = glm::vec4(1); </div>
<div class="line">};</div>
</div><!-- fragment --><p>Barycentrické souřadnice musíte spočítat podle obsahů: </p><div class="image">
<object type="image/svg+xml" data="barycentric2D.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Barycentrické souřadnice ve 2D jsou spočítány jako poměry obsahů podtrojúhelníků.</div></div>
<p> Hlouba se interpoluje pomocí barycentrických souřadnic ve 2D: </p><p class="formulaDsp">
\[\displaystyle fragment.gl\_FragCoord.z = vertex[0].gl\_Position.z\cdot \lambda_0^{2D} + vertex[1].gl\_Position.z\cdot \lambda_1^{2D} + vertex[2].gl\_Position.z\cdot \lambda_2^{2D}\]
</p>
<p> Hloubka vrcholů vertex[].gl_Position.z vznikla při perspektivním dělení.</p>
<h3><a class="anchor" id="attInterp_test"></a>
17., 18. Ověření, zda se správně interpolují vertex attributy.</h3>
<p>Tyto dva testy ověřují, jestli se správně interpolují vertex atributy do fragment atributů. </p><div class="fragment"><div class="line">izgProject -c --test 17</div>
<div class="line">izgProject -c --test 18</div>
</div><!-- fragment --><p> Vertex Attributy jsou se struktuře <a class="el" href="structOutVertex.html" title="[InVertex]">OutVertex</a> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structOutVertex.html">OutVertex</a>{</div>
<div class="line">  <a class="code" href="unionAttribute.html">Attribute</a> <a class="code" href="structOutVertex.html#ad1d48203a36e3ee510841f25a5bc068e">attributes</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>]                     ; </div>
<div class="line">  glm::vec4 <a class="code" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a>               = glm::vec4(0,0,0,1); </div>
<div class="line">};</div>
</div><!-- fragment --><p>A ze tří těchto vrcholů by se měly interpolovat atributy <a class="el" href="structInFragment.html" title="[OutVertex]">InFragment</a>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structInFragment.html">InFragment</a>{</div>
<div class="line">  <a class="code" href="unionAttribute.html">Attribute</a> <a class="code" href="structInFragment.html#af9cd9e9a684a1c454d52d7e191564be1">attributes</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>]               ; </div>
<div class="line">  glm::vec4 <a class="code" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">gl_FragCoord</a>              = glm::vec4(1); </div>
<div class="line">};</div>
</div><!-- fragment --><p>Interpolujte pouze ty atributy, které jsou poznačené v položce <a class="el" href="structProgram.html#a5b48bbf6bc459552b066757369a0f86d">Program::vs2fs</a>! </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structProgram.html">Program</a>{</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#af647cdb302d7e978c6a0da41a0a92725">VertexShader</a>   <a class="code" href="structProgram.html#a2bcea678985527f04a87be358ff1f78b">vertexShader</a>   = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a52f1704ae0b129e49fe1902e05319ad6">FragmentShader</a> <a class="code" href="structProgram.html#a5faf623d0af27d6000ebcacafecf2eb5">fragmentShader</a> = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code" href="structUniforms.html">Uniforms</a>       <a class="code" href="structProgram.html#a857fb2633d95dd4381cd06a24130d1ef">uniforms</a>                ; </div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a349a9cde14be8097df865ba0469c0ab2">AttributeType</a>  <a class="code" href="structProgram.html#a5b48bbf6bc459552b066757369a0f86d">vs2fs</a>[<a class="code" href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a>] = {<a class="code" href="fwd_8hpp.html#a349a9cde14be8097df865ba0469c0ab2aba2b45bdc11e2a4a6e86aab2ac693cbb">AttributeType::EMPTY</a>}; </div>
<div class="line">};</div>
</div><!-- fragment --><p>Atributy je potřeba interpolovat pomocí perspektivně korektně upravených barycentrických souřadnic. Perspektivní korektní interpolace: </p><p class="formulaDsp">
\[\displaystyle \frac{\frac{A_0 \cdot \lambda_0^{2D}}{h_0} + \frac{A_1 \cdot \lambda_1^{2D}}{h_1} + \frac{A_2 \cdot \lambda_2^{2D}}{h_2}}{\frac{\lambda_0^{2D}}{h_0}+\frac{\lambda_1^{2D}}{h_1}+\frac{\lambda_2^{2D}}{h_2}}\]
</p>
<p> Kde \(\lambda_0^{2D},\lambda_1^{2D},\lambda_2^{2D}\) jsou barycentrické koordináty ve 2D, \(h_0,h_1,h_2\) je homogenní složka vrcholů a \(A_0,A_1,A_2\) je atribut vrcholu.<br  />
 Homogenní složka vrcholů je čtvrtá složka - tím čím se dělilo ve perspektivním dělení: h0 = vertex[0].gl_Position.w, h1 = vertex[1].gl_Position.w, ... <br  />
 Barycentrické souřadnice je možné přepočítat na perspektivně koretní barycentrické souřadnice (je to jen přepsání zvorečku nahoře): </p><p class="formulaDsp">
\[\displaystyle s = \frac{\lambda_0^{2D}}{h_0}+\frac{\lambda_1^{2D}}{h_1}+\frac{\lambda_2^{2D}}{h_2}\]
</p>
 <p class="formulaDsp">
\[\displaystyle \lambda_0 = \frac{\lambda_0^{2D}}{h_0\cdot s}\]
</p>
 <p class="formulaDsp">
\[\displaystyle \lambda_1 = \frac{\lambda_1^{2D}}{h_1\cdot s}\]
</p>
 <p class="formulaDsp">
\[\displaystyle \lambda_2 = \frac{\lambda_2^{2D}}{h_2\cdot s}\]
</p>
<p> Ty je potom možné použít pro interpolaci atributů: </p><p class="formulaDsp">
\[\displaystyle fragment.attribute = vertex[0].attribute\cdot \lambda_0 + vertex[1].attribute\cdot \lambda_1 + vertex[2].attribute\cdot \lambda_2\]
</p>
 <div class="image">
<object type="image/svg+xml" data="interpolation.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Rasterizace a interpolace vertex atributů. Vertex Atributy jsou interpolovány pomocí perspektivně korektních barycentrických souřadnic l0,l1,l2.</div></div>
<h2><a class="anchor" id="pfo"></a>
3. Úkol - naprogramovat per fragment operace a zápis do framebufferu.</h2>
<p>Rastrovou část zobrazovacího řetězce už byla částečně nakousnutá v předcházejícím úkolu (byl volán fragment shader). Rastrová část vypadá takto: </p><div class="image">
<object type="image/svg+xml" data="pipeline_raster.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Rastrová část je složena z fragment shaderu a per fragment operací. Jsou dvě PFO operace: hloubkový test a blending. Fragmenty se poté přimíchají do framebufferu.</div></div>
<p> PFO operují s výstupním fragmentem fragment shaderu <a class="el" href="structOutFragment.html" title="[InFragment]">OutFragment</a> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structOutFragment.html">OutFragment</a>{</div>
<div class="line">  glm::vec4 <a class="code" href="structOutFragment.html#a9670bf5a31a5c23fccdbeaad959cc3cf">gl_FragColor</a> = glm::vec4(0.f); </div>
<div class="line">};</div>
</div><!-- fragment --><p>Jeho hloubkou ("z" komponenta <a class="el" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">InFragment::gl_FragCoord</a> InFragment::gl_FragCoord.z)<br  />
 A framebufferem <a class="el" href="structFrame.html" title="[Program]">Frame</a> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structFrame.html">Frame</a>{</div>
<div class="line">  uint8_t* <a class="code" href="structFrame.html#ab797ae32df945ee20162acb0ce3ccd42">color</a>  = <span class="keyword">nullptr</span>; </div>
<div class="line">  <span class="keywordtype">float</span>  * <a class="code" href="structFrame.html#a3b9db2c521a7553301b61c7c72da513a">depth</a>  = <span class="keyword">nullptr</span>; </div>
<div class="line">  uint32_t <a class="code" href="structFrame.html#a529d9ad34efc99722ce92580f8eddd15">width</a>  = 0      ; </div>
<div class="line">  uint32_t <a class="code" href="structFrame.html#a095a92799a36149100a0b95a936a4996">height</a> = 0      ; </div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="depthTest"></a>
Hloubkový test</h3>
<p>Hloubkový test je jedna z per fragment operací. Stará se o zahazování fragmentů, které jsou hlouběji než to, co už se vyrasterizovalo. Využívá k tomu hloubkový buffer. Pokud je hloubka nového fragment menší, je jeho barva a hloubka zapsána do framebufferu. Dejte pozor na přetečení rozsahu <a class="el" href="structOutFragment.html#a9670bf5a31a5c23fccdbeaad959cc3cf">OutFragment::gl_FragColor</a>. Před zápisem je nutné ořezat barvu do rozsahu &lt;0,1&gt; a pak převést na bajty [0-255]. </p><div class="image">
<object type="image/svg+xml" data="PFO.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Vizualizace depth testu. Starý fragment (jeho barva a hloubka) je nahrazen pokud má nový fragment menší hloubku.</div></div>
<h3><a class="anchor" id="blending"></a>
Blending</h3>
<p>Blending je PFO operace, která místo toho, aby barvu ve framebuffer přepsala novou barvou fragmentu, tak ji smíchá. Blending má v reálu mnoho nastavení, v projetku se používá pouze alpha blending.<br  />
 Fragmenty mají barvu RGBA, kde A - \(\alpha\) je tzv. neprůhlednost.<br  />
 Pokud má nový fragment \(\alpha=1\) - je absolutně neprůhledný - plně přepíše barvu ve framebufferu, když projde hloubkovým testem.<br  />
 Pokud má nový fragment \(\alpha=0\) - je absolutně průhledný - vůbec barvu ve framebuffer nezmění, i když projde hloubkovým testem.<br  />
 Pokud má hodnotu někde mezi, tak se barva lineárně smíchá: </p><p class="formulaDsp">
\[\displaystyle colorBuffer_{rgb} = colorBuffer_{rgb} \cdot (1-\alpha) + gl\_FragColor_{rgb} \cdot \alpha\]
</p>
<p> Kde \(\alpha=gl\_FragColor_a\)</p>
<h3><a class="anchor" id="blending"></a>
Blending</h3>
<p>V tomto projektu je trošičku zmodifikován blending. Pokud má fragment příliš velkou průhlednost \(\alpha \leq 0.5\), nebude modifikovat hloubu, a nechá takouvou, která tam byla. Tato modifikace v reálu obvykle neexistuje, je tady jako kompromis pro zlepšení kvality vykreslování. K per fragment operacím se vážou testy 19. - 23. </p>
<h3><a class="anchor" id="pfo_test"></a>
19. - 23. Ověření, zda se správně fungují per fragment operace</h3>
<p>Tyto testy ověřují, jestli se správně provádí per fragment operace a zápis do framebufferu. </p><div class="fragment"><div class="line">izgProject -c --test 19</div>
<div class="line">izgProject -c --test 20</div>
<div class="line">izgProject -c --test 21</div>
<div class="line">izgProject -c --test 22</div>
<div class="line">izgProject -c --test 23</div>
</div><!-- fragment --><p> Upravený pseudokód funkce může vypadat takto: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> runVertexAssembly(){</div>
<div class="line">  computeVertexID()</div>
<div class="line">  readVertexAttributes();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> runPrimitiveAssembly(primitive,<a class="code" href="structVertexArray.html">VertexArray</a> vao,t,<a class="code" href="structProgram.html">Program</a> prg){</div>
<div class="line">  <span class="keywordflow">for</span>(every vertex v in triangle){</div>
<div class="line">    <a class="code" href="structInVertex.html">InVertex</a> inVertex;</div>
<div class="line">    runVertexAssembly(inVertex,vao,t+v);</div>
<div class="line">    prg.vertexShader(primitive.vertex,inVertex,prg.uniforms);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> rasterizeTriangle(frame,primitive,prg){</div>
<div class="line">  <span class="keywordflow">for</span>(pixels in frame){</div>
<div class="line">    <span class="keywordflow">if</span>(pixels in primitive){</div>
<div class="line">      <a class="code" href="structInFragment.html">InFragment</a> inFragment;</div>
<div class="line">      createFragment(inFragment,primitive,barycentrics,pixelCoord,prg);</div>
<div class="line">      <a class="code" href="structOutFragment.html">OutFragment</a> outFragment;</div>
<div class="line">      prg.fragmentShader(outFragment,inFragment,uniforms);</div>
<div class="line">      clampColor(outFragment,0,1);</div>
<div class="line">      perFragmentOperations(frame,outFragment,inFragment.<a class="code" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">gl_FragCoord</a>.z)</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="gpu_8hpp.html#ab74fb851bb0923d1cc071b461939cc3c">drawTriangles</a>(<a class="code" href="structGPUContext.html">GPUContext</a>&amp;ctx,uint32_t nofVertices){</div>
<div class="line">  <span class="keywordflow">for</span>(every triangle t){</div>
<div class="line">    Primitive primitive;</div>
<div class="line">    runPrimitiveAssembly(primitive,ctx.<a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>,t,ctx.<a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>)</div>
<div class="line"> </div>
<div class="line">    runPerspectiveDivision(primitive)</div>
<div class="line">    runViewportTransformation(primitive,ctx.frame)</div>
<div class="line">    rasterizeTriangle(ctx.frame,primitive,ctx.prg);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Pokud to všechno budete mít hotové, mělo by vám začít fungovat zobrazování. Jestli ano, gratuluji. Máte první část hotovou.<br  />
</p>
<h2><a class="anchor" id="clip"></a>
4. Úkol - naprogramovat ořez trojúhelníků blízkou ořezovou rovinou</h2>
<p>Tento úkol opravuje vykreslování pokud je geometrie za pozorovatelem.<br  />
 Tyto úkoly můžete přeskočit a vrátit se k nim později. Pokud se na geometrii budete dívat tak, že leží vždy před vámi, nepoznáte rozdíl.<br  />
 Testy to jsou 24. - 27. </p><div class="fragment"><div class="line">izgProject -c --test 24</div>
<div class="line">izgProject -c --test 25</div>
<div class="line">izgProject -c --test 26</div>
<div class="line">izgProject -c --test 27</div>
</div><!-- fragment --><p> A upravený pseudokód může vypadat takto: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> runVertexAssembly(){</div>
<div class="line">  computeVertexID()</div>
<div class="line">  readVertexAttributes();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> runPrimitiveAssembly(primitive,<a class="code" href="structVertexArray.html">VertexArray</a> vao,t,<a class="code" href="structProgram.html">Program</a> prg){</div>
<div class="line">  <span class="keywordflow">for</span>(every vertex v in triangle){</div>
<div class="line">    <a class="code" href="structInVertex.html">InVertex</a> inVertex;</div>
<div class="line">    runVertexAssembly(inVertex,vao,t+v);</div>
<div class="line">    prg.vertexShader(primitive.vertex,inVertex,prg.uniforms);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> rasterizeTriangle(frame,primitive,prg){</div>
<div class="line">  <span class="keywordflow">for</span>(pixels in frame){</div>
<div class="line">    <span class="keywordflow">if</span>(pixels in primitive){</div>
<div class="line">      <a class="code" href="structInFragment.html">InFragment</a> inFragment;</div>
<div class="line">      createFragment(inFragment,primitive,barycentrics,pixelCoord,prg);</div>
<div class="line">      <a class="code" href="structOutFragment.html">OutFragment</a> outFragment;</div>
<div class="line">      prg.fragmentShader(outFragment,inFragment,uniforms);</div>
<div class="line">      clampColor(outFragment,0,1);</div>
<div class="line">      perFragmentOperations(frame,outFragment,inFragment.<a class="code" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">gl_FragCoord</a>.z)</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="gpu_8hpp.html#ab74fb851bb0923d1cc071b461939cc3c">drawTriangles</a>(<a class="code" href="structGPUContext.html">GPUContext</a>&amp;ctx,uint32_t nofVertices){</div>
<div class="line">  <span class="keywordflow">for</span>(every triangle t){</div>
<div class="line">    Primitive primitive;</div>
<div class="line">    runPrimitiveAssembly(primitive,ctx.<a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>,t,ctx.<a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>)</div>
<div class="line"> </div>
<div class="line">    ClippedPrimitive clipped;</div>
<div class="line">    performeClipping(clipped,primitive);</div>
<div class="line"> </div>
<div class="line">    for(all clipped triangle c in clipped){</div>
<div class="line">      runPerspectiveDivision(c)</div>
<div class="line">      runViewportTransformation(c,ctx.<a class="code" href="structGPUContext.html#ab632150244bd53d4ed01fab7fd93be51">frame</a>)</div>
<div class="line">      rasterizeTriangle(ctx.frame,c,ctx.prg);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="Clipping"></a>
Clipping</h3>
<p>Ořez (clipping) slouží pro odstranění částí trojúhelníků, které leží mimo pohledový jehlan. Nejdůležitější je však ořez near ořezovou rovinou pohledoveho jehlanu. Pokud by se neprovedl ořez pomocí near roviny, pak by se vrcholy nebo i celé trojúhělníky, které leží za středem projekce promítly při perspektivním dělení na průmětnu. Ořez se provádí v clip-space - po Primitive Assembly jednotce. Pro body, které leží uvnitř pohledového tělesa platí, že jejich souřadnice splňují následující nerovnice: \( -A_w \leq A_i \leq +A_w \), \(i \in \left\{ x,y,z \right\}\). Těchto 6 nerovnic reprezentuje jednotlivé svěny pohledového jehlanu. Nerovnice \( -A_w \leq A_z \) reprezentuje podmínku pro near ořezovou rovinu. <br  />
 Při ořezu trojúhelníku můžou nastat 4 případy, jsou znázorněny na následujícím obrázku:</p>
<div class="image">
<object type="image/svg+xml" data="clip_variants.svg" style="pointer-events: none;"></object>
<div class="caption">
4 varianty ořezu trojúhelníku pomocí near roviny. Počet vrcholů, které leží před ořezovou rovinou určuje typ ořezu. Při ořezu může vzniknout 0 až 2 nové trojúhelníky.</div></div>
<p>Ořez trojúhelníku pomocí near roviny lze zjednodušit na ořez hran trojúhelníku. Bod na hraně (úsečce) trojúhelníku lze vyjádřit jako: \( \overrightarrow{X(t)} = \overrightarrow{A} + t \cdot (\overrightarrow{B}-\overrightarrow{A}) \), \(t \in [0,1] \). \( \overrightarrow{A}, \overrightarrow{B} \) jsou vrcholy trojúhelníka, \( \overrightarrow{X(t)} \) je bod na hraně a parametr \( t \) udává posun na úsečce.</p>
<div class="image">
<object type="image/svg+xml" data="clip.svg" style="pointer-events: none;"></object>
<div class="caption">
Ořez trojúhelníku pomocí ořezu hran. Při ořezu hran vzniknou nové body, ze kterých jsou následně sestaveny nové trojúhelníky.</div></div>
<p>Souřadnice bodu \( \overrightarrow{X(t)} \) lze určit při vypočtení parametru \( t \), při kterém přestane platit nerovnice pro near rovinu \( -X(t)_w \leq X(t)_z \). Takové místo nastává v situaci \( -X(t)_w = X(t)_z \). Po dosazení z rovnice úsečky lze vztah přepsat na: </p><p class="formulaDsp">
\begin{eqnarray*} -X(t)_w &amp;=&amp; X(t)_z \\ 0 &amp;=&amp; X(t)_w + X(t)_z \\ 0 &amp;=&amp; A_w + t \cdot (B_w-A_w) + A_z + t \cdot (B_z - A_z) \\ 0 &amp;=&amp; A_w + A_z + t \cdot (B_w-A_w+B_z-A_z) \\ -A_w-A_z &amp;=&amp; t \cdot (B_w-A_w+B_z-A_z) \\ \frac{-A_w - A_z}{B_w-A_w+B_z-A_z} &amp;=&amp; t\\ \end{eqnarray*}
</p>
<p>Pozice bodu \( \overrightarrow{X(t)} \) a hodnoty dalších vertex atributů lze vypočítat lineární kombinací hodnot z vrcholů úsečky pomocí parametru \( t \) následovně: \( \overrightarrow{X(t)} = \overrightarrow{A} + t \cdot (\overrightarrow{B}-\overrightarrow{A}) \).</p>
<p>Celý vykreslovací řetězec je zobrazen na následujícím obrázku: </p><div class="image">
<object type="image/svg+xml" data="rendering_pipeline.svg" style="pointer-events: none;"></object>
<div class="caption">
Simplified rendering pipeline</div></div>
 <div class="image">
<object type="image/svg+xml" data="examples.svg" width="1000" style="pointer-events: none;"></object>
<div class="caption">
příklady</div></div>
<h2><a class="anchor" id="drawModel_fce"></a>
5. Úkol - Vykreslování modelů - funkce drawModel</h2>
<p>Tento úkol už se neváže k zobrazovacímu řetězci, ale k jeho využívání. Cílem je naprogramovat zobrazování modelů načtených ze souboru na disku. Načítání modelů už je uděláno a předpřipraveno. Vaším úkolem je jen správně pustit kreslení. Budete editovat funkci <a class="el" href="drawModel_8hpp.html#ac14f542e0c0210cb47b47abcfa2fc279">drawModel</a> v souboru <a class="el" href="drawModel_8cpp.html">student/drawModel.cpp</a>. A vykreslení budete volat funkci drawTriangles (nikoliv drawTrianglesImpl - je to z důvodů testů).<br  />
 Pro čtení z textur můžete použít funkci <a class="el" href="gpu_8hpp.html#abf6cca928d7eb5a455aed9776b59aaee">read_texture</a>.<br  />
 Struktura modelu je: </p><div class="image">
<object type="image/svg+xml" data="model.svg" style="pointer-events: none;"></object>
<div class="caption">
Model je složen ze 3 polí: pole kořenů, pole meshu a pole textur. Kořen je uzel, který může mít potomky a může se odkazovat na mesh. Mesh obsahuje nastavení pro funkci drawTriangles a může se odkazovat na texturu.</div></div>
<p> Vážou s k němu struktury <a class="el" href="structModel.html" title="[Node]">Model</a>, <a class="el" href="structNode.html" title="[Mesh]">Node</a>, <a class="el" href="structMesh.html" title="[GPUContext]">Mesh</a>, <a class="el" href="structTexture.html" title="This struct represent a texture.">Texture</a>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structModel.html">Model</a>{</div>
<div class="line">  std::vector&lt;Mesh   &gt;<a class="code" href="structModel.html#a6797d253b3c7ca6f90a99d1b7abd0b79">meshes</a>  ;</div>
<div class="line">  std::vector&lt;Node   &gt;<a class="code" href="structModel.html#ac1fcef5b98a4c88e5fec3672180e85f1">roots</a>   ;</div>
<div class="line">  std::vector&lt;Texture&gt;<a class="code" href="structModel.html#ace109d8eec99777f72694b7d49b2224f">textures</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structNode.html">Node</a>{</div>
<div class="line">  glm::mat4        <a class="code" href="structNode.html#a825a38e1f0d49fcc1a0cdbad46473bf2">modelMatrix</a> = glm::mat4(1.f);</div>
<div class="line">  int32_t          <a class="code" href="structNode.html#ad4e3fcf9fdbd325a83e87cfb7ab86554">mesh</a> = -1;                   </div>
<div class="line">  std::vector&lt;Node&gt;<a class="code" href="structNode.html#af7ddc81358470c3bf7a7819c8b77f53d">children</a>;                    </div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structMesh.html">Mesh</a>{</div>
<div class="line">  <span class="keywordtype">void</span> <span class="keyword">const</span>*  <a class="code" href="structMesh.html#a09f57e0a52794948ebe36772b471488b">indices</a>     = nullptr          ;</div>
<div class="line">  <a class="code" href="fwd_8hpp.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839">IndexType</a>    <a class="code" href="structMesh.html#a55de606f67f2aa169ef7b51042ade990">indexType</a>   = <a class="code" href="fwd_8hpp.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839a17266551181f69a1b4a3ad5c9e270afc">IndexType::UINT32</a>;</div>
<div class="line">  <a class="code" href="structVertexAttrib.html">VertexAttrib</a> <a class="code" href="structMesh.html#a00f5a9d0221fc4e66dc165520a835460">position</a>                       ;</div>
<div class="line">  <a class="code" href="structVertexAttrib.html">VertexAttrib</a> <a class="code" href="structMesh.html#abc59ae5bf8f9b8d5b806e6e91ae5e1f5">normal</a>                         ;</div>
<div class="line">  <a class="code" href="structVertexAttrib.html">VertexAttrib</a> <a class="code" href="structMesh.html#a64c4b4488ba4d235f2b6e7c0e4d47cd7">texCoord</a>                       ;</div>
<div class="line">  uint32_t     <a class="code" href="structMesh.html#ad60502867a78d6e442172d1ea5b679d6">nofIndices</a>  = 0                ;</div>
<div class="line">  glm::vec4    <a class="code" href="structMesh.html#a12235d3eae977558b64d1f5ec3022db7">diffuseColor</a> = glm::vec4(1.f)  ;</div>
<div class="line">  <span class="keywordtype">int</span>          <a class="code" href="structMesh.html#ad0ab81099a4d195182afafa8c03c8371">diffuseTexture</a> = -1            ;</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structTexture.html">Texture</a>{</div>
<div class="line">  uint8_t <span class="keyword">const</span>* <a class="code" href="structTexture.html#adb1d02bd501bdbbde95de1aba0030875">data</a>     = <span class="keyword">nullptr</span>;</div>
<div class="line">  uint32_t       <a class="code" href="structTexture.html#a48c85d8e7c257d854238980f5bcc3b75">width</a>    = 0      ;</div>
<div class="line">  uint32_t       <a class="code" href="structTexture.html#a35691eb813ceb8467b436092b1c9d8ed">height</a>   = 0      ;</div>
<div class="line">  uint32_t       <a class="code" href="structTexture.html#ae1f2c7acab562a820bc75ab37f0db3c8">channels</a> = 3      ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Pro správné vykreslení, je potřeba projít kořeny modelu a vykreslit všechny nodes v pre order pořadí <a href="https://en.wikipedia.org/wiki/Tree_traversal">pre order</a>. Uzly se mohou odkazovat na mesh nebo nemusí (pokud je mesh=-1).<br  />
 <a class="el" href="structMesh.html" title="[GPUContext]">Mesh</a> se může odkazovat na texturu nebo nemusí (pokud je diffuseTexture=-1).<br  />
 V zásadě jde o to ke každému uzlu, ve kterém je odkaz na mesh zavolat funkci <a class="el" href="gpu_8hpp.html#ab74fb851bb0923d1cc071b461939cc3c">drawTriangles</a> kterou jste naprogramovali.<br  />
 Je potřeba správně spočítat modelovou matici, která se buduje postupný pronásobováním.<br  />
 Vykreslení jde napsat s výhodou rekurzivně. Pseudokód možné implementace: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> drawNode(<a class="code" href="structGPUContext.html">GPUContext</a>&amp;ctx,<a class="code" href="structNode.html">Node</a> <span class="keyword">const</span>&amp;node,<a class="code" href="structModel.html">Model</a> <span class="keyword">const</span>&amp;model,glm::mat4 <span class="keyword">const</span>&amp;prubeznaMatice){</div>
<div class="line">  <span class="keywordflow">if</span>(node.<a class="code" href="structNode.html#ad4e3fcf9fdbd325a83e87cfb7ab86554">mesh</a>&gt;=0){</div>
<div class="line">    mesh = model.<a class="code" href="structModel.html#a6797d253b3c7ca6f90a99d1b7abd0b79">meshes</a>[node.<a class="code" href="structNode.html#ad4e3fcf9fdbd325a83e87cfb7ab86554">mesh</a>];</div>
<div class="line"> </div>
<div class="line">    ctx.<a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>.<a class="code" href="structProgram.html#a857fb2633d95dd4381cd06a24130d1ef">uniforms</a>.<a class="code" href="structUniforms.html#ac1130b74094bf1d7eaa9e18b332deff9">uniform</a>[1].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a> = ZKOBINUJ(prubeznaMatice,node.<a class="code" href="structNode.html#a825a38e1f0d49fcc1a0cdbad46473bf2">modelMatrix</a>);</div>
<div class="line">    ctx.<a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>.<a class="code" href="structProgram.html#a857fb2633d95dd4381cd06a24130d1ef">uniforms</a>.<a class="code" href="structUniforms.html#ac1130b74094bf1d7eaa9e18b332deff9">uniform</a>[2].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a> = inverzni tranponovana...</div>
<div class="line">    ctx.<a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>.attribute[0] = mesh.position ...</div>
<div class="line">    ...</div>
<div class="line">    ctx.<a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>.<a class="code" href="structVertexArray.html#ae7da1c1e5a13ae73e038d87bd0359ce6">indexBuffer</a> = ...</div>
<div class="line">    <span class="keywordflow">if</span>(mesh.diffuseTexture&gt;=0)</div>
<div class="line">      ctx.<a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>.<a class="code" href="structProgram.html#a857fb2633d95dd4381cd06a24130d1ef">uniforms</a>.<a class="code" href="structUniforms.html#a0be49c6c3e3b457991afe344138a3103">textures</a>[0] = model.<a class="code" href="structModel.html#ace109d8eec99777f72694b7d49b2224f">textures</a>[mesh.diffuseTexture];</div>
<div class="line">    ...</div>
<div class="line">    <a class="code" href="gpu_8hpp.html#ab74fb851bb0923d1cc071b461939cc3c">drawTriangles</a>(ctx,mesh.nofIndices);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0;i&lt;node.<a class="code" href="structNode.html#af7ddc81358470c3bf7a7819c8b77f53d">children</a>.size();++i)</div>
<div class="line">    drawNode(ctx,node.<a class="code" href="structNode.html#af7ddc81358470c3bf7a7819c8b77f53d">children</a>[i],model,...); rekurze</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="drawModel_8cpp.html#ac14f542e0c0210cb47b47abcfa2fc279">drawModel</a>(){</div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line">  glm::mat4 jednotkovaMatrice = glm::mat4(1.f);</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0;i&lt;model.<a class="code" href="structModel.html#ac1fcef5b98a4c88e5fec3672180e85f1">roots</a>.size();++i)</div>
<div class="line">    drawNode(...,model.<a class="code" href="structModel.html#ac1fcef5b98a4c88e5fec3672180e85f1">roots</a>[i],... , jednotkovaMatrice);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Příklad, jak vykreslit geometrii, můžete najít v souboru examples/phongMethod.cpp </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> vertexShader(<a class="code" href="structOutVertex.html">OutVertex</a>&amp;outVertex,<a class="code" href="structInVertex.html">InVertex</a> <span class="keyword">const</span>&amp;inVertex,<a class="code" href="structUniforms.html">Uniforms</a> <span class="keyword">const</span>&amp;uniforms){</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> pos = glm::vec4(inVertex.<a class="code" href="structInVertex.html#a4fc269d49110daa41aedf9b8f313f0ca">attributes</a>[0].<a class="code" href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">v3</a>,1.f);</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp;nor = inVertex.<a class="code" href="structInVertex.html#a4fc269d49110daa41aedf9b8f313f0ca">attributes</a>[1].<a class="code" href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">v3</a>;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp;viewMatrix       = uniforms.<a class="code" href="structUniforms.html#ac1130b74094bf1d7eaa9e18b332deff9">uniform</a>[0].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp;projectionMatrix = uniforms.<a class="code" href="structUniforms.html#ac1130b74094bf1d7eaa9e18b332deff9">uniform</a>[1].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> mvp = projectionMatrix*viewMatrix;</div>
<div class="line"> </div>
<div class="line">  outVertex.<a class="code" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a> = mvp * pos;</div>
<div class="line">  outVertex.<a class="code" href="structOutVertex.html#ad1d48203a36e3ee510841f25a5bc068e">attributes</a>[0].<a class="code" href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">v3</a> = pos;</div>
<div class="line">  outVertex.<a class="code" href="structOutVertex.html#ad1d48203a36e3ee510841f25a5bc068e">attributes</a>[1].<a class="code" href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">v3</a> = nor;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> fragmentShader(<a class="code" href="structOutFragment.html">OutFragment</a>&amp;outFragment,<a class="code" href="structInFragment.html">InFragment</a> <span class="keyword">const</span>&amp;inFragment,<a class="code" href="structUniforms.html">Uniforms</a> <span class="keyword">const</span>&amp;uniforms){</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp; light          = uniforms.<a class="code" href="structUniforms.html#ac1130b74094bf1d7eaa9e18b332deff9">uniform</a>[2].<a class="code" href="unionUniform.html#a70392e438c775c6213e6c2dec76b29c4">v3</a>;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp; cameraPosition = uniforms.<a class="code" href="structUniforms.html#ac1130b74094bf1d7eaa9e18b332deff9">uniform</a>[3].<a class="code" href="unionUniform.html#a70392e438c775c6213e6c2dec76b29c4">v3</a>;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp; vpos           = inFragment.<a class="code" href="structInFragment.html#af9cd9e9a684a1c454d52d7e191564be1">attributes</a>[0].<a class="code" href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">v3</a>;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp; vnor           = inFragment.<a class="code" href="structInFragment.html#af9cd9e9a684a1c454d52d7e191564be1">attributes</a>[1].<a class="code" href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">v3</a>;</div>
<div class="line">  <span class="keyword">auto</span> vvnor = glm::normalize(vnor);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> l = glm::normalize(light-vpos);</div>
<div class="line">  <span class="keywordtype">float</span> diffuseFactor                    = glm::dot(l, vvnor);</div>
<div class="line">  <span class="keywordflow">if</span> (diffuseFactor &lt; 0.f) diffuseFactor = 0.f;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> v = glm::normalize(cameraPosition-vpos);</div>
<div class="line">  <span class="keyword">auto</span> r = -glm::reflect(v,vvnor);</div>
<div class="line">  <span class="keywordtype">float</span> specularFactor                     = glm::dot(r, l);</div>
<div class="line">  <span class="keywordflow">if</span> (specularFactor &lt; 0.f) specularFactor = 0.f;</div>
<div class="line">  <span class="keywordtype">float</span> <span class="keyword">const</span> shininess                    = 40.f;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (diffuseFactor &lt; 0)</div>
<div class="line">    specularFactor = 0;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    specularFactor = powf(specularFactor, shininess);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">float</span> t = vvnor[1];</div>
<div class="line">  <span class="keywordflow">if</span>(t&lt;0.f)t=0.f;</div>
<div class="line">  t*=t;</div>
<div class="line">  <span class="keyword">auto</span> materialDiffuseColor = glm::mix(glm::vec3(0.f,1.f,0.f),glm::vec3(1.f,1.f,1.f),t);</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">float</span> <span class="keyword">const</span> nofStripes = 10;</div>
<div class="line">  <span class="keywordtype">float</span> factor = 1.f / nofStripes * 2.f;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> xs = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(glm::mod(vpos.x+glm::sin(vpos.y*10.f)*.1f,factor)/factor &gt; 0.5);</div>
<div class="line"> </div>
<div class="line">  materialDiffuseColor = glm::mix(glm::mix(glm::vec3(0.f,.5f,0.f),glm::vec3(1.f,1.f,0.f),xs),glm::vec3(1.f),t);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> materialSpecularColor = glm::vec3(1.f);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> diffuseColor  = materialDiffuseColor  * diffuseFactor;</div>
<div class="line">  <span class="keyword">auto</span> specularColor = materialSpecularColor * specularFactor;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> color = glm::min(diffuseColor + specularColor,glm::vec3(1.f));</div>
<div class="line">  outFragment.<a class="code" href="structOutFragment.html#a9670bf5a31a5c23fccdbeaad959cc3cf">gl_FragColor</a> = glm::vec4(color,1.f);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Method::Method(MethodConstructionData <span class="keyword">const</span>*){</div>
<div class="line">  <span class="comment">//position</span></div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>.<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[0].<a class="code" href="structVertexAttrib.html#a8a69adafb547d0991fa7031771b5771d">bufferData</a> = bunnyVertices      ;</div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>.<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[0].<a class="code" href="structVertexAttrib.html#a0b722b51b4528b50603e99722329d41a">type</a>       = <a class="code" href="fwd_8hpp.html#a349a9cde14be8097df865ba0469c0ab2aa7c116def9f212182aa52ab1e936d77d">AttributeType::VEC3</a>;</div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>.<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[0].<a class="code" href="structVertexAttrib.html#aef250d71bce43e96a6efb9180f24d079">stride</a>     = <span class="keyword">sizeof</span>(BunnyVertex);</div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>.<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[0].<a class="code" href="structVertexAttrib.html#a58f3129f893d0ce72ec7d364fef21840">offset</a>     = 0                  ;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//normal</span></div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>.<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[1].<a class="code" href="structVertexAttrib.html#a8a69adafb547d0991fa7031771b5771d">bufferData</a> = bunnyVertices      ;</div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>.<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[1].<a class="code" href="structVertexAttrib.html#a0b722b51b4528b50603e99722329d41a">type</a>       = <a class="code" href="fwd_8hpp.html#a349a9cde14be8097df865ba0469c0ab2aa7c116def9f212182aa52ab1e936d77d">AttributeType::VEC3</a>;</div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>.<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[1].<a class="code" href="structVertexAttrib.html#aef250d71bce43e96a6efb9180f24d079">stride</a>     = <span class="keyword">sizeof</span>(BunnyVertex);</div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>.<a class="code" href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">vertexAttrib</a>[1].<a class="code" href="structVertexAttrib.html#a58f3129f893d0ce72ec7d364fef21840">offset</a>     = <span class="keyword">sizeof</span>(glm::vec3)  ;</div>
<div class="line"> </div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>.<a class="code" href="structVertexArray.html#ae7da1c1e5a13ae73e038d87bd0359ce6">indexBuffer</a> = bunnyIndices     ;</div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">vao</a>.<a class="code" href="structVertexArray.html#a7822420a93f7334ffdb1a0992de59ae3">indexType</a>   = <a class="code" href="fwd_8hpp.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839a17266551181f69a1b4a3ad5c9e270afc">IndexType::UINT32</a>;</div>
<div class="line"> </div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>.<a class="code" href="structProgram.html#a2bcea678985527f04a87be358ff1f78b">vertexShader</a>   = vertexShader;</div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>.<a class="code" href="structProgram.html#a5faf623d0af27d6000ebcacafecf2eb5">fragmentShader</a> = fragmentShader;</div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>.<a class="code" href="structProgram.html#a5b48bbf6bc459552b066757369a0f86d">vs2fs</a>[0]       = <a class="code" href="fwd_8hpp.html#a349a9cde14be8097df865ba0469c0ab2aa7c116def9f212182aa52ab1e936d77d">AttributeType::VEC3</a>;</div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>.<a class="code" href="structProgram.html#a5b48bbf6bc459552b066757369a0f86d">vs2fs</a>[1]       = <a class="code" href="fwd_8hpp.html#a349a9cde14be8097df865ba0469c0ab2aa7c116def9f212182aa52ab1e936d77d">AttributeType::VEC3</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Method::onDraw(<a class="code" href="structFrame.html">Frame</a>&amp;frame,glm::mat4 <span class="keyword">const</span>&amp;proj,glm::mat4 <span class="keyword">const</span>&amp;view,glm::vec3 <span class="keyword">const</span>&amp;light,glm::vec3 <span class="keyword">const</span>&amp;camera){</div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#ab632150244bd53d4ed01fab7fd93be51">frame</a> = frame;</div>
<div class="line">  <a class="code" href="gpu_8cpp.html#ab7d3aa14be823b93893b0cd2cb33abd0">clear</a>(ctx,.5f,.5f,.5f,1.f);</div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>.<a class="code" href="structProgram.html#a857fb2633d95dd4381cd06a24130d1ef">uniforms</a>.<a class="code" href="structUniforms.html#ac1130b74094bf1d7eaa9e18b332deff9">uniform</a>[0].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a> = view  ;</div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>.<a class="code" href="structProgram.html#a857fb2633d95dd4381cd06a24130d1ef">uniforms</a>.<a class="code" href="structUniforms.html#ac1130b74094bf1d7eaa9e18b332deff9">uniform</a>[1].<a class="code" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a> = proj  ;</div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>.<a class="code" href="structProgram.html#a857fb2633d95dd4381cd06a24130d1ef">uniforms</a>.<a class="code" href="structUniforms.html#ac1130b74094bf1d7eaa9e18b332deff9">uniform</a>[2].<a class="code" href="unionUniform.html#a70392e438c775c6213e6c2dec76b29c4">v3</a> = light ;</div>
<div class="line">  ctx.<a class="code" href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">prg</a>.<a class="code" href="structProgram.html#a857fb2633d95dd4381cd06a24130d1ef">uniforms</a>.<a class="code" href="structUniforms.html#ac1130b74094bf1d7eaa9e18b332deff9">uniform</a>[3].<a class="code" href="unionUniform.html#a70392e438c775c6213e6c2dec76b29c4">v3</a> = camera;</div>
<div class="line">  <a class="code" href="gpu_8hpp.html#ab74fb851bb0923d1cc071b461939cc3c">drawTriangles</a>(ctx,<span class="keyword">sizeof</span>(bunnyIndices)/<span class="keyword">sizeof</span>(VertexIndex));</div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --><p>K tomuto úkolu se vážou testy 28. a 35. </p><div class="fragment"><div class="line">izgProject -c --test 28</div>
<div class="line">izgProject -c --test 29</div>
<div class="line">izgProject -c --test 30</div>
<div class="line">izgProject -c --test 31</div>
<div class="line">izgProject -c --test 32</div>
<div class="line">izgProject -c --test 33</div>
<div class="line">izgProject -c --test 34</div>
<div class="line">izgProject -c --test 35</div>
</div><!-- fragment --><h2><a class="anchor" id="drawModel_vs"></a>
6. Úkol - Vykreslování modelů - vertex shader drawModel_vertexShader</h2>
<p>Funkce <a class="el" href="drawModel_8hpp.html#af28c26a23a26d8bb27f8a24833037c3c">drawModel_vertexShader</a> reprezentuje vertex shader pro zobrazení modelů.<br  />
 Její funkcionalita spočívá v transformování vrcholů pomocí matic.<br  />
 Vstupem jsou vrcholy, které mají pozici (3f), normálu (3f) a texturovací souřadnice (2f) (atributy 0, 1 a 2).<br  />
 Výstupem jsou vrcholy, které mají pozici (3f), normálu (3f) ve world space a atribut texturovacích souřadnic (2f) (atributy 0, 1 a 2).<br  />
 Uniformní proměnné obsahují projectionView matici, modelovou matici, a inverzní transponovanou matici (uniformy 0,1,2).<br  />
 Pozice by se měla pronásobit modelovou maticí m*glm::vec4(pos,1.f) aby se ztransformovala do world-space.<br  />
 Normála by se měla pronásobit inverzní transponovanou modelovou maticí itm*glm::vec4(nor,0.f) aby se dostala do world-space.<br  />
 Texturovací souřadnice se pouze přepošlou.<br  />
 Pozice vrcholu gl_Position by měla být vypočtena pronásobením projectionView*model*pos.<br  />
 K tomuto úkolu se váže tests 36. </p><div class="fragment"><div class="line">izgProject -c --test 36</div>
</div><!-- fragment --><h2><a class="anchor" id="drawModel_fs"></a>
7. Úkol - Vykreslování modelů - fragment shader drawMode_fragmentShader</h2>
<p>Funkce <a class="el" href="drawModel_8hpp.html#a00d11e84945ed4f7699102c077328bd0">drawModel_fragmentShader</a> reprezentuje fragment shader pro zobrazení modelů.<br  />
 Její funkcionalita spočívá v obarvování fragmentů a počítání lambertova osvětlovacího modelu.<br  />
 Vstupem jsou fragmenty, které mají: pozici (3f), normálu (3f), texturovací souřadnice (2f) (atributy 0,1,2).<br  />
 Výstupem je fragment s barvou a správnou \(\alpha\). Uniformní proměnné obsahují pozici světla (3f), difuzní barvu (4f), a příznak textury (1f) (uniformy 3,5,6).<br  />
 Dále uniformní proměnné obsahují difuzní texturu (4f) (uniform.textures[0]).<br  />
 Vstupní normálu byste měli znormalizovat N=glm::normalize(nor).<br  />
 Difuzní barva materiálu je buď uložena v uniformní proměnné 5 nebo v textuře.<br  />
 Rozhoduje se podle toho, jestli je uniformní proměnná 6. &gt; 0, pokud ano, využije se textura, když ne využije se uniformní proměnná 5. Spočítejte lambertův osvětlovací model s ambientním faktorem 0.2. K tomuto úkolu se vážou testy 37. a 38. </p><div class="fragment"><div class="line">izgProject -c --test 37</div>
<div class="line">izgProject -c --test 38</div>
</div><!-- fragment --><h1><a class="anchor" id="rozdeleni"></a>
Rozdělení</h1>
<p>Projekt je rozdělen do několika podsložek:</p>
<p><b>student/</b> Tato složka obsahuje soubory, které využijete při implementaci projektu. Složka obsahuje soubory, které budete odevzávat a podpůrné hlavičkové soubory.</p>
<p><b>examples/</b> Tato složka obsahuje přiložené příklady, které využívají vámi vytvořené zobrazovadlo.</p>
<p><b>tests/</b> Tato složka obsahuje akceptační a performanční testy projektu. Akceptační testy jsou napsány s využitím knihovny catch. Testy jsou rozděleny do testovacích případů (TEST_CASE). Daný TEST_CASE testuje jednu podčást projektu.</p>
<p><b>libs/</b> Tato složka obsahuje pomocné knihovny <b>framework/</b> Tato složka obsahuje interní záležitosti projektu. Všechny soubory jsou napsány v C++, abyste se mohli podívat, jak to funguje.</p>
<p><b>doc/</b> Tato složka obsahuje doxygen dokumentaci projektu. Můžete ji přegenerovat pomocí příkazu doxygen spuštěného v root adresáři projektu.</p>
<p><b>resources/</b> Tato složka obsahuje modely a obrázky.</p>
<p><b>build/</b> Tady se čeká, že si budete sestavovat projekt, ale není to nutné, pokud víte, co děláte...</p>
<p>Složka student/ obsahuje soubory, které se vás přímo týkají:</p>
<p><a class="el" href="gpu_8cpp.html">gpu.cpp</a> obsahuje definici vykreslovací funkce <a class="el" href="gpu_8cpp.html#a2ad1fed3d7e6cddf0f9a3bd339992f40">drawTrianglesImpl</a> - tady odvedete nejvíce práce.</p>
<p><a class="el" href="drawModel_8cpp.html">drawModel.cpp</a> obsahuje definici funkce pro vykreslení modelu <a class="el" href="drawModel_8hpp.html#ac14f542e0c0210cb47b47abcfa2fc279">drawModel</a> a vertex a fragment shaderu <a class="el" href="drawModel_8hpp.html#af28c26a23a26d8bb27f8a24833037c3c">drawModel_vertexShader</a> <a class="el" href="drawModel_8hpp.html#a00d11e84945ed4f7699102c077328bd0">drawModel_fragmentShader</a> - toto máte taky naprogramovat.</p>
<p><a class="el" href="fwd_8hpp.html">fwd.hpp</a> obsahuje definice typů a konstanty - projděte si.</p>
<p>Projekt je postaven nad filozofií OpenGL/Vulkan.</p>
<h1><a class="anchor" id="sestaveni"></a>
Sestavení</h1>
<p>Projekt byl testován na Ubuntu 20.04, Visual Studio 2017, 2019. Projekt vyžaduje 64 bitové sestavení. Projekt využívá build systém <a href="https://cmake.org/">CMAKE</a>. CMake je program, který na základně konfiguračních souborů "CMakeLists.txt" vytvoří "makefile" v daném vývojovém prostředí. Dokáže generovat makefile pro Linux, mingw, solution file pro Microsoft Visual Studio, a další.<br  />
 Postup Linux: </p><div class="fragment"><div class="line"># stáhnout projekt</div>
<div class="line">unzip izgProject.zip -d izgProject</div>
<div class="line">cd izgProject/build</div>
<div class="line">cmake ..</div>
<div class="line">make -j8</div>
<div class="line">./izgProject</div>
<div class="line">./izgProject -h</div>
</div><!-- fragment --><p> Posup na Windows:</p><ol type="1">
<li>stáhnout projekt</li>
<li>rozbalit projekt</li>
<li>jděte do složky build/</li>
<li>ve složce build pusťte cmake-gui ..</li>
<li>pokud nevíte jak, tak pusťte cmake-gui a nastavte "Where is the source code:" na složku s projektem (obsahuje CMakeLists.txt)</li>
<li>a "Where to build the binaries: " na složku build</li>
<li>configure</li>
<li>generate</li>
<li>Otevřete vygenerovnou Microsoft Visual Studio Solution soubor.</li>
</ol>
<h1><a class="anchor" id="spousteni"></a>
Spouštění</h1>
<p>Projekt je možné po úspěšném přeložení pustit přes aplikaci <b>izgProject</b>. Projekt akceptuje několik argumentů příkazové řádky, pro jejich výpis použijte parametr <b> -h </b></p><ul>
<li><b>-c</b> spustí akceptační testy.</li>
<li><b>-c -g CESTA_NEKAM/izgProject/resources/images/output.png</b> spustí akceptační cesty (pouze pokud jste si někam nešikovně přesunuli soubory...)</li>
<li><b>-p</b> spustí performanční test. (vhodné až pokud aplikaci zkompilujete v RELEASE) Vyzkoušejte si <div class="fragment"><div class="line">izgProject -i</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="ovladani"></a>
Ovládání</h1>
<p><a class="el" href="structProgram.html" title="[VertexArray]">Program</a> se ovládá pomocí myši a klávesnice:</p><ul>
<li>stisknuté levé tlačítko myši + pohyb myší - rotace kamery</li>
<li>stisknuté pravé tlačítko myši + pohyb myší - přiblížení kamery</li>
<li>stiknuté prostření tlačítko myši + pohyb myší - posun kamery do boků</li>
<li>"n" - přepne na další scénu/metodu</li>
<li>"p" - přepne na předcházející scénu/metodu</li>
<li>"esc" - konec</li>
</ul>
<h1><a class="anchor" id="testovani"></a>
Testování</h1>
<p>Vaši implementaci si můžete ověřit sadou vestavěných akceptačních testů. Když aplikaci pustíte s parametrem "-c", pustí se akceptační testy, které ověřují funkčnost vaší implementace. </p><div class="fragment"><div class="line">./izgProject -c</div>
</div><!-- fragment --><p> Pokud není nějaký test splněn, vypíše se k němu komentář s informacemi, co je špatně. Testy jsou seřazeny a měly by se plnit postupně. Pokud chcete pustit jeden konrétní test (třeba 13.), pusťte aplikaci s parametry "-c --test 13". </p><div class="fragment"><div class="line">./izgProject -c --test 13</div>
</div><!-- fragment --><p> Pokud chcete pustit všechny testy až po jeden konkrétní (třeba 5.), pusťte aplikaci s parametry "-c --up-to-test --test 5". </p><div class="fragment"><div class="line">./izgProject -c --test 5 --up-to-test</div>
</div><!-- fragment --><p> To je užitečné, když implementujete sekci, a chcete vědět, jestli jste něco zpětně nerozbili.<br  />
 Na konci výpisu testů se vám vypíše bodové hodnocení.</p>
<h1><a class="anchor" id="odevzdavani"></a>
Odevzdávání</h1>
<p>Před odevzdáváním si zkontrolujte, že váš projekt lze přeložit na merlinovi.<br  />
 Pro ověření kompilace nemusíte na merlin kopírovat složku resources (je velká).<br  />
 Pokud si chcete na merlinovi ověřit i akceptační testy stačí zkopírovat jen resources/images/output.png a resources/models/china.glb.<br  />
 Zkopirujte projekt na merlin a spusťte skript: <b>./merlinCompilationTest.sh</b>.<br  />
<br  />
 Odevzdávejte pouze soubory <a class="el" href="gpu_8cpp.html" title="This file contains implementation of gpu.">gpu.cpp</a>, <a class="el" href="drawModel_8cpp.html" title="This file contains functions for model rendering.">drawModel.cpp</a> Soubory zabalte do archivu proj.zip. Po rozbalení archivu se <b>NESMÍ</b> vytvořit žádná složka. Příkazy pro ověření na Linuxu: zip proj.zip <a class="el" href="gpu_8cpp.html" title="This file contains implementation of gpu.">gpu.cpp</a> <a class="el" href="drawModel_8cpp.html" title="This file contains functions for model rendering.">drawModel.cpp</a>, unzip proj.zip. Studenti pracují na řešení projektu samostatně a každý odevzdá své vlastní řešení. Poraďte si, ale řešení vypracujte samostatně! </p>
<h1><a class="anchor" id="chyby"></a>
Časté chyby, které nedělejte</h1>
<ol>
<li>
student se mě nezeptá pokud neví, jak něco vyřešit. Ptejte se. Odpovím, pokud budu vědět. </li>
<li>
student se mě nezeptá pokud neví, jak něco vyřešit. Ptejte se. Odpovím, pokud budu vědět. </li>
<li>
student se mě nezeptá pokud neví, jak něco vyřešit. Ptejte se. Odpovím, pokud budu vědět. </li>
<li>
student neodevzdá koretně zabalené soubory. </li>
<li>
student si inkluduje nějake soubory z windows, třeba windows.h - to nedělejte, překlad musí fungovat na merlinovi. </li>
<li>
min, max funkce si berete odnikud - vyzkoušejte, jestli vám jde překlad na merlinovi, nebo použijte glm::min, glm::max </li>
<li>
špatně pojmenovaný archiv při odevzdávání </li>
<li>
soubory navíc, nebo přejmenované soubory v odevzdaném archivu </li>
<li>
memory corruption, přistupujete do paměti, kam nemáte (na to je valgrind) </li>
<li>
student odevzdá soubory v nějakém exotickém archivu, rar, tar.gz, 7z, iso... </li>
<li>
student zkouší projekt na systemu, který nebyl ověřen (ověřeno to bylo na Linuxu a Windows). </li>
<li>
VirtualBox s Ubuntu je +- možný, ale může se narazit na SDL chybu no video device (asi je potřeba nainstalovat SDL: sudo apt install libsdl2-dev). </li>
<li>
Nějaký problém se CMake a zprovoznením překladu na Windows (většinou je problém s cestami, zkuste dát projekt někan do jednoduché složky C:). </li>
</ol>
<h1><a class="anchor" id="hodnoceni"></a>
Hodnocení</h1>
<p>Množství bodů, které dostanete, je odvozeno od množství splněných akceptačních testů a podle toho, zda vám to kreslí správně (s jistou tolerancí kvůli nepřesnosti floatové aritmetiky). Automatické opravování má k dispozici větší množství akceptačních testů (kdyby někoho napadlo je obejít). Pokud vám aplikace spadne v rámci testů, dostanete 0 bodů. Pokud aplikace nepůjde přeložit, dostanete 0 bodů.</p>
<h1><a class="anchor" id="soutez"></a>
Soutěž</h1>
<p>Pokud váš projekt obdrží plný počet bodů, bude zařazen do soutěže o nejrychlejší implementaci zobrazovacího řetězce. Můžete přeimplementovat cokoliv v odevzdávaných souborech pokud to projde akceptačními testy a kompilací.</p>
<h1><a class="anchor" id="zaver"></a>
Závěrem</h1>
<p>Ať se dílo daří a ať vás grafika alespoň trochu baví! V případě potřeby se nebojte zeptat (napište přímo vedoucímu projektu <a href="#" onclick="location.href='mai'+'lto:'+'imi'+'le'+'t@f'+'it'+'.vu'+'tb'+'r.c'+'z'; return false;">imile<span style="display: none;">.nosp@m.</span>t@fi<span style="display: none;">.nosp@m.</span>t.vut<span style="display: none;">.nosp@m.</span>br.c<span style="display: none;">.nosp@m.</span>z</a> nebojte se napsat, nekoušu (a teď při korona viru ani nemůžu)). </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="astructProgram_html_a5b48bbf6bc459552b066757369a0f86d"><div class="ttname"><a href="structProgram.html#a5b48bbf6bc459552b066757369a0f86d">Program::vs2fs</a></div><div class="ttdeci">AttributeType vs2fs[maxAttributes]</div><div class="ttdoc">which attributes are interpolated from vertex shader to fragment shader</div><div class="ttdef"><b>Definition:</b> fwd.hpp:194</div></div>
<div class="ttc" id="agpu_8hpp_html_ab74fb851bb0923d1cc071b461939cc3c"><div class="ttname"><a href="gpu_8hpp.html#ab74fb851bb0923d1cc071b461939cc3c">drawTriangles</a></div><div class="ttdeci">void(* drawTriangles)(GPUContext &amp;ctx, uint32_t n)</div><div class="ttdoc">Function that renders triangles.</div></div>
<div class="ttc" id="astructUniforms_html_a0be49c6c3e3b457991afe344138a3103"><div class="ttname"><a href="structUniforms.html#a0be49c6c3e3b457991afe344138a3103">Uniforms::textures</a></div><div class="ttdeci">Texture textures[maxTextures]</div><div class="ttdoc">textures</div><div class="ttdef"><b>Definition:</b> fwd.hpp:117</div></div>
<div class="ttc" id="afwd_8hpp_html_a2bfb0a0ff1c379a8b4e8f9d24fdd4839a48d8f1a723d44ff4a87db1bb6c551c62"><div class="ttname"><a href="fwd_8hpp.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839a48d8f1a723d44ff4a87db1bb6c551c62">IndexType::UINT16</a></div><div class="ttdeci">@ UINT16</div><div class="ttdoc">uin16_t type</div></div>
<div class="ttc" id="astructNode_html"><div class="ttname"><a href="structNode.html">Node</a></div><div class="ttdoc">[Mesh]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:247</div></div>
<div class="ttc" id="aunionAttribute_html_a7e4149eff36adcf056cb7153bfbf4c8c"><div class="ttname"><a href="unionAttribute.html#a7e4149eff36adcf056cb7153bfbf4c8c">Attribute::v3</a></div><div class="ttdeci">glm::vec3 v3</div><div class="ttdoc">vector of three floats</div><div class="ttdef"><b>Definition:</b> fwd.hpp:53</div></div>
<div class="ttc" id="astructMesh_html_ad0ab81099a4d195182afafa8c03c8371"><div class="ttname"><a href="structMesh.html#ad0ab81099a4d195182afafa8c03c8371">Mesh::diffuseTexture</a></div><div class="ttdeci">int diffuseTexture</div><div class="ttdoc">diffuse texture or -1 (no texture)</div><div class="ttdef"><b>Definition:</b> fwd.hpp:239</div></div>
<div class="ttc" id="astructUniforms_html"><div class="ttname"><a href="structUniforms.html">Uniforms</a></div><div class="ttdoc">[Uniform]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:115</div></div>
<div class="ttc" id="astructModel_html_a6797d253b3c7ca6f90a99d1b7abd0b79"><div class="ttname"><a href="structModel.html#a6797d253b3c7ca6f90a99d1b7abd0b79">Model::meshes</a></div><div class="ttdeci">std::vector&lt; Mesh &gt; meshes</div><div class="ttdoc">list of all meshes in model</div><div class="ttdef"><b>Definition:</b> fwd.hpp:259</div></div>
<div class="ttc" id="astructInVertex_html_aa4d31911053492bffe4b41dae12ee000"><div class="ttname"><a href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">InVertex::gl_VertexID</a></div><div class="ttdeci">uint32_t gl_VertexID</div><div class="ttdoc">vertex id</div><div class="ttdef"><b>Definition:</b> fwd.hpp:64</div></div>
<div class="ttc" id="afwd_8hpp_html_a4a3d1b76496eeb849f86584b59091f7a"><div class="ttname"><a href="fwd_8hpp.html#a4a3d1b76496eeb849f86584b59091f7a">maxAttributes</a></div><div class="ttdeci">const uint32_t maxAttributes</div><div class="ttdoc">maximum number of vertex/fragment attributes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:16</div></div>
<div class="ttc" id="afwd_8hpp_html_a2bfb0a0ff1c379a8b4e8f9d24fdd4839aecfc091ed2a607335524c8389cfa41b5"><div class="ttname"><a href="fwd_8hpp.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839aecfc091ed2a607335524c8389cfa41b5">IndexType::UINT8</a></div><div class="ttdeci">@ UINT8</div><div class="ttdoc">uin8_t type</div></div>
<div class="ttc" id="astructOutVertex_html_ad1d48203a36e3ee510841f25a5bc068e"><div class="ttname"><a href="structOutVertex.html#ad1d48203a36e3ee510841f25a5bc068e">OutVertex::attributes</a></div><div class="ttdeci">Attribute attributes[maxAttributes]</div><div class="ttdoc">vertex attributes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:73</div></div>
<div class="ttc" id="afwd_8hpp_html_a4c2eb5328acb9e61d6477a9bdba62dac"><div class="ttname"><a href="fwd_8hpp.html#a4c2eb5328acb9e61d6477a9bdba62dac">maxTextures</a></div><div class="ttdeci">const uint32_t maxTextures</div><div class="ttdoc">maximum number of textures</div><div class="ttdef"><b>Definition:</b> fwd.hpp:18</div></div>
<div class="ttc" id="agpu_8cpp_html_ab7d3aa14be823b93893b0cd2cb33abd0"><div class="ttname"><a href="gpu_8cpp.html#ab7d3aa14be823b93893b0cd2cb33abd0">clear</a></div><div class="ttdeci">void clear(GPUContext &amp;ctx, float r, float g, float b, float a)</div><div class="ttdoc">This function clears framebuffer.</div><div class="ttdef"><b>Definition:</b> gpu.cpp:53</div></div>
<div class="ttc" id="astructFrame_html"><div class="ttname"><a href="structFrame.html">Frame</a></div><div class="ttdoc">[Program]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:203</div></div>
<div class="ttc" id="adrawModel_8cpp_html_ac14f542e0c0210cb47b47abcfa2fc279"><div class="ttname"><a href="drawModel_8cpp.html#ac14f542e0c0210cb47b47abcfa2fc279">drawModel</a></div><div class="ttdeci">void drawModel(GPUContext &amp;ctx, Model const &amp;model, glm::mat4 const &amp;proj, glm::mat4 const &amp;view, glm::vec3 const &amp;light, glm::vec3 const &amp;camera)</div><div class="ttdoc">This function renders a model.</div><div class="ttdef"><b>Definition:</b> drawModel.cpp:22</div></div>
<div class="ttc" id="astructVertexAttrib_html"><div class="ttname"><a href="structVertexAttrib.html">VertexAttrib</a></div><div class="ttdoc">[FragmentShader]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:164</div></div>
<div class="ttc" id="astructGPUContext_html_aa0ce4ed40751f5f8ec6921b5b146ef31"><div class="ttname"><a href="structGPUContext.html#aa0ce4ed40751f5f8ec6921b5b146ef31">GPUContext::prg</a></div><div class="ttdeci">Program prg</div><div class="ttdoc">active program (shaders, uniforms, textures)</div><div class="ttdef"><b>Definition:</b> fwd.hpp:221</div></div>
<div class="ttc" id="astructGPUContext_html_ab632150244bd53d4ed01fab7fd93be51"><div class="ttname"><a href="structGPUContext.html#ab632150244bd53d4ed01fab7fd93be51">GPUContext::frame</a></div><div class="ttdeci">Frame frame</div><div class="ttdoc">active frame (output of rendering)</div><div class="ttdef"><b>Definition:</b> fwd.hpp:222</div></div>
<div class="ttc" id="astructModel_html_ace109d8eec99777f72694b7d49b2224f"><div class="ttname"><a href="structModel.html#ace109d8eec99777f72694b7d49b2224f">Model::textures</a></div><div class="ttdeci">std::vector&lt; Texture &gt; textures</div><div class="ttdoc">list of all textures in model</div><div class="ttdef"><b>Definition:</b> fwd.hpp:261</div></div>
<div class="ttc" id="astructMesh_html_ad60502867a78d6e442172d1ea5b679d6"><div class="ttname"><a href="structMesh.html#ad60502867a78d6e442172d1ea5b679d6">Mesh::nofIndices</a></div><div class="ttdeci">uint32_t nofIndices</div><div class="ttdoc">nofIndices or nofVertices (if there is no indexing)</div><div class="ttdef"><b>Definition:</b> fwd.hpp:237</div></div>
<div class="ttc" id="astructMesh_html"><div class="ttname"><a href="structMesh.html">Mesh</a></div><div class="ttdoc">[GPUContext]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:231</div></div>
<div class="ttc" id="astructNode_html_ad4e3fcf9fdbd325a83e87cfb7ab86554"><div class="ttname"><a href="structNode.html#ad4e3fcf9fdbd325a83e87cfb7ab86554">Node::mesh</a></div><div class="ttdeci">int32_t mesh</div><div class="ttdoc">id of mesh or -1 if no mesh</div><div class="ttdef"><b>Definition:</b> fwd.hpp:249</div></div>
<div class="ttc" id="astructFrame_html_a529d9ad34efc99722ce92580f8eddd15"><div class="ttname"><a href="structFrame.html#a529d9ad34efc99722ce92580f8eddd15">Frame::width</a></div><div class="ttdeci">uint32_t width</div><div class="ttdoc">width of frame</div><div class="ttdef"><b>Definition:</b> fwd.hpp:206</div></div>
<div class="ttc" id="astructUniforms_html_ac1130b74094bf1d7eaa9e18b332deff9"><div class="ttname"><a href="structUniforms.html#ac1130b74094bf1d7eaa9e18b332deff9">Uniforms::uniform</a></div><div class="ttdeci">Uniform uniform[maxUniforms]</div><div class="ttdoc">uniform variables</div><div class="ttdef"><b>Definition:</b> fwd.hpp:116</div></div>
<div class="ttc" id="astructOutFragment_html_a9670bf5a31a5c23fccdbeaad959cc3cf"><div class="ttname"><a href="structOutFragment.html#a9670bf5a31a5c23fccdbeaad959cc3cf">OutFragment::gl_FragColor</a></div><div class="ttdeci">glm::vec4 gl_FragColor</div><div class="ttdoc">fragment color</div><div class="ttdef"><b>Definition:</b> fwd.hpp:93</div></div>
<div class="ttc" id="astructOutVertex_html"><div class="ttname"><a href="structOutVertex.html">OutVertex</a></div><div class="ttdoc">[InVertex]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:72</div></div>
<div class="ttc" id="astructModel_html_ac1fcef5b98a4c88e5fec3672180e85f1"><div class="ttname"><a href="structModel.html#ac1fcef5b98a4c88e5fec3672180e85f1">Model::roots</a></div><div class="ttdeci">std::vector&lt; Node &gt; roots</div><div class="ttdoc">list of roots of node trees</div><div class="ttdef"><b>Definition:</b> fwd.hpp:260</div></div>
<div class="ttc" id="astructGPUContext_html"><div class="ttname"><a href="structGPUContext.html">GPUContext</a></div><div class="ttdoc">[Frame]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:219</div></div>
<div class="ttc" id="aunionUniform_html_ad2afb58e290202cd23e444440e1b1f07"><div class="ttname"><a href="unionUniform.html#ad2afb58e290202cd23e444440e1b1f07">Uniform::v4</a></div><div class="ttdeci">glm::vec4 v4</div><div class="ttdoc">four floats</div><div class="ttdef"><b>Definition:</b> fwd.hpp:106</div></div>
<div class="ttc" id="astructGPUContext_html_a49c145dff8fcb1c62c1d2eacfa757263"><div class="ttname"><a href="structGPUContext.html#a49c145dff8fcb1c62c1d2eacfa757263">GPUContext::vao</a></div><div class="ttdeci">VertexArray vao</div><div class="ttdoc">active vertex array (input/ triangles)</div><div class="ttdef"><b>Definition:</b> fwd.hpp:220</div></div>
<div class="ttc" id="astructVertexArray_html_ae7da1c1e5a13ae73e038d87bd0359ce6"><div class="ttname"><a href="structVertexArray.html#ae7da1c1e5a13ae73e038d87bd0359ce6">VertexArray::indexBuffer</a></div><div class="ttdeci">void const  * indexBuffer</div><div class="ttdoc">pointer to index buffer of NULL</div><div class="ttdef"><b>Definition:</b> fwd.hpp:179</div></div>
<div class="ttc" id="astructMesh_html_a12235d3eae977558b64d1f5ec3022db7"><div class="ttname"><a href="structMesh.html#a12235d3eae977558b64d1f5ec3022db7">Mesh::diffuseColor</a></div><div class="ttdeci">glm::vec4 diffuseColor</div><div class="ttdoc">default diffuseColor (if there is no texture)</div><div class="ttdef"><b>Definition:</b> fwd.hpp:238</div></div>
<div class="ttc" id="astructProgram_html_a2bcea678985527f04a87be358ff1f78b"><div class="ttname"><a href="structProgram.html#a2bcea678985527f04a87be358ff1f78b">Program::vertexShader</a></div><div class="ttdeci">VertexShader vertexShader</div><div class="ttdoc">vertex shader</div><div class="ttdef"><b>Definition:</b> fwd.hpp:191</div></div>
<div class="ttc" id="astructTexture_html_a35691eb813ceb8467b436092b1c9d8ed"><div class="ttname"><a href="structTexture.html#a35691eb813ceb8467b436092b1c9d8ed">Texture::height</a></div><div class="ttdeci">uint32_t height</div><div class="ttdoc">height of the texture</div><div class="ttdef"><b>Definition:</b> fwd.hpp:27</div></div>
<div class="ttc" id="aunionAttribute_html_ac47131c7c30814e28f0c4662a4ed2737"><div class="ttname"><a href="unionAttribute.html#ac47131c7c30814e28f0c4662a4ed2737">Attribute::v4</a></div><div class="ttdeci">glm::vec4 v4</div><div class="ttdoc">vector of four floats</div><div class="ttdef"><b>Definition:</b> fwd.hpp:54</div></div>
<div class="ttc" id="astructProgram_html_a5faf623d0af27d6000ebcacafecf2eb5"><div class="ttname"><a href="structProgram.html#a5faf623d0af27d6000ebcacafecf2eb5">Program::fragmentShader</a></div><div class="ttdeci">FragmentShader fragmentShader</div><div class="ttdoc">fragment shader</div><div class="ttdef"><b>Definition:</b> fwd.hpp:192</div></div>
<div class="ttc" id="afwd_8hpp_html_a7d487fa31fd72d7d5b6d952880a2f137"><div class="ttname"><a href="fwd_8hpp.html#a7d487fa31fd72d7d5b6d952880a2f137">maxUniforms</a></div><div class="ttdeci">const uint32_t maxUniforms</div><div class="ttdoc">maximum number of uniform variables</div><div class="ttdef"><b>Definition:</b> fwd.hpp:17</div></div>
<div class="ttc" id="aunionAttribute_html_aa240c263ec02c39b48d662a1c598e1fc"><div class="ttname"><a href="unionAttribute.html#aa240c263ec02c39b48d662a1c598e1fc">Attribute::v2</a></div><div class="ttdeci">glm::vec2 v2</div><div class="ttdoc">vector of two floats</div><div class="ttdef"><b>Definition:</b> fwd.hpp:52</div></div>
<div class="ttc" id="afwd_8hpp_html_a349a9cde14be8097df865ba0469c0ab2aa7c116def9f212182aa52ab1e936d77d"><div class="ttname"><a href="fwd_8hpp.html#a349a9cde14be8097df865ba0469c0ab2aa7c116def9f212182aa52ab1e936d77d">AttributeType::VEC3</a></div><div class="ttdeci">@ VEC3</div><div class="ttdoc">3x 32-bit floats</div></div>
<div class="ttc" id="aunionUniform_html_a2714f4ff3e6703bccdac2c92dcad3b25"><div class="ttname"><a href="unionUniform.html#a2714f4ff3e6703bccdac2c92dcad3b25">Uniform::v1</a></div><div class="ttdeci">float v1</div><div class="ttdoc">single float</div><div class="ttdef"><b>Definition:</b> fwd.hpp:103</div></div>
<div class="ttc" id="afwd_8hpp_html_af647cdb302d7e978c6a0da41a0a92725"><div class="ttname"><a href="fwd_8hpp.html#af647cdb302d7e978c6a0da41a0a92725">VertexShader</a></div><div class="ttdeci">void(*)(OutVertex &amp;outVertex, InVertex const  &amp;inVertex, Uniforms const  &amp;uniforms) VertexShader</div><div class="ttdoc">[IndexType]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:143</div></div>
<div class="ttc" id="astructVertexAttrib_html_a58f3129f893d0ce72ec7d364fef21840"><div class="ttname"><a href="structVertexAttrib.html#a58f3129f893d0ce72ec7d364fef21840">VertexAttrib::offset</a></div><div class="ttdeci">uint64_t offset</div><div class="ttdoc">offset in bytes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:167</div></div>
<div class="ttc" id="astructFrame_html_ab797ae32df945ee20162acb0ce3ccd42"><div class="ttname"><a href="structFrame.html#ab797ae32df945ee20162acb0ce3ccd42">Frame::color</a></div><div class="ttdeci">uint8_t * color</div><div class="ttdoc">color buffer</div><div class="ttdef"><b>Definition:</b> fwd.hpp:204</div></div>
<div class="ttc" id="astructVertexAttrib_html_a0b722b51b4528b50603e99722329d41a"><div class="ttname"><a href="structVertexAttrib.html#a0b722b51b4528b50603e99722329d41a">VertexAttrib::type</a></div><div class="ttdeci">AttributeType type</div><div class="ttdoc">type of attribute</div><div class="ttdef"><b>Definition:</b> fwd.hpp:168</div></div>
<div class="ttc" id="astructTexture_html_a48c85d8e7c257d854238980f5bcc3b75"><div class="ttname"><a href="structTexture.html#a48c85d8e7c257d854238980f5bcc3b75">Texture::width</a></div><div class="ttdeci">uint32_t width</div><div class="ttdoc">width of the texture</div><div class="ttdef"><b>Definition:</b> fwd.hpp:26</div></div>
<div class="ttc" id="aunionUniform_html"><div class="ttname"><a href="unionUniform.html">Uniform</a></div><div class="ttdoc">[OutFragment]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:101</div></div>
<div class="ttc" id="afwd_8hpp_html_a52f1704ae0b129e49fe1902e05319ad6"><div class="ttname"><a href="fwd_8hpp.html#a52f1704ae0b129e49fe1902e05319ad6">FragmentShader</a></div><div class="ttdeci">void(*)(OutFragment &amp;outFragment, InFragment const  &amp;inFragment, Uniforms const  &amp;uniforms) FragmentShader</div><div class="ttdoc">[VertexShader]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:157</div></div>
<div class="ttc" id="astructVertexArray_html_a7822420a93f7334ffdb1a0992de59ae3"><div class="ttname"><a href="structVertexArray.html#a7822420a93f7334ffdb1a0992de59ae3">VertexArray::indexType</a></div><div class="ttdeci">IndexType indexType</div><div class="ttdoc">type of indices</div><div class="ttdef"><b>Definition:</b> fwd.hpp:180</div></div>
<div class="ttc" id="astructProgram_html"><div class="ttname"><a href="structProgram.html">Program</a></div><div class="ttdoc">[VertexArray]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:190</div></div>
<div class="ttc" id="astructMesh_html_a64c4b4488ba4d235f2b6e7c0e4d47cd7"><div class="ttname"><a href="structMesh.html#a64c4b4488ba4d235f2b6e7c0e4d47cd7">Mesh::texCoord</a></div><div class="ttdeci">VertexAttrib texCoord</div><div class="ttdoc">tex. coord vertex attribute</div><div class="ttdef"><b>Definition:</b> fwd.hpp:236</div></div>
<div class="ttc" id="astructProgram_html_a857fb2633d95dd4381cd06a24130d1ef"><div class="ttname"><a href="structProgram.html#a857fb2633d95dd4381cd06a24130d1ef">Program::uniforms</a></div><div class="ttdeci">Uniforms uniforms</div><div class="ttdoc">uniform variables</div><div class="ttdef"><b>Definition:</b> fwd.hpp:193</div></div>
<div class="ttc" id="astructTexture_html"><div class="ttname"><a href="structTexture.html">Texture</a></div><div class="ttdoc">This struct represent a texture.</div><div class="ttdef"><b>Definition:</b> fwd.hpp:24</div></div>
<div class="ttc" id="astructMesh_html_a09f57e0a52794948ebe36772b471488b"><div class="ttname"><a href="structMesh.html#a09f57e0a52794948ebe36772b471488b">Mesh::indices</a></div><div class="ttdeci">void const  * indices</div><div class="ttdoc">indices to vertices or nullptr</div><div class="ttdef"><b>Definition:</b> fwd.hpp:232</div></div>
<div class="ttc" id="astructVertexArray_html"><div class="ttname"><a href="structVertexArray.html">VertexArray</a></div><div class="ttdoc">[VertexAttrib]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:177</div></div>
<div class="ttc" id="astructOutVertex_html_a9ca7de8eef8d688163497a7d34c76d7b"><div class="ttname"><a href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">OutVertex::gl_Position</a></div><div class="ttdeci">glm::vec4 gl_Position</div><div class="ttdoc">clip space position</div><div class="ttdef"><b>Definition:</b> fwd.hpp:74</div></div>
<div class="ttc" id="astructTexture_html_adb1d02bd501bdbbde95de1aba0030875"><div class="ttname"><a href="structTexture.html#adb1d02bd501bdbbde95de1aba0030875">Texture::data</a></div><div class="ttdeci">uint8_t const  * data</div><div class="ttdoc">pointer to data</div><div class="ttdef"><b>Definition:</b> fwd.hpp:25</div></div>
<div class="ttc" id="astructVertexAttrib_html_aef250d71bce43e96a6efb9180f24d079"><div class="ttname"><a href="structVertexAttrib.html#aef250d71bce43e96a6efb9180f24d079">VertexAttrib::stride</a></div><div class="ttdeci">uint64_t stride</div><div class="ttdoc">stride in bytes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:166</div></div>
<div class="ttc" id="astructInFragment_html"><div class="ttname"><a href="structInFragment.html">InFragment</a></div><div class="ttdoc">[OutVertex]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:82</div></div>
<div class="ttc" id="agpu_8cpp_html_a2ad1fed3d7e6cddf0f9a3bd339992f40"><div class="ttname"><a href="gpu_8cpp.html#a2ad1fed3d7e6cddf0f9a3bd339992f40">drawTrianglesImpl</a></div><div class="ttdeci">void drawTrianglesImpl(GPUContext &amp;ctx, uint32_t nofVertices)</div><div class="ttdoc">[drawTrianglesImpl]</div><div class="ttdef"><b>Definition:</b> gpu.cpp:14</div></div>
<div class="ttc" id="astructVertexArray_html_a3cd8e8e07596edcbeb6cab4b56a4242d"><div class="ttname"><a href="structVertexArray.html#a3cd8e8e07596edcbeb6cab4b56a4242d">VertexArray::vertexAttrib</a></div><div class="ttdeci">VertexAttrib vertexAttrib[maxAttributes]</div><div class="ttdoc">settings for vertex attributes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:178</div></div>
<div class="ttc" id="astructTexture_html_ae1f2c7acab562a820bc75ab37f0db3c8"><div class="ttname"><a href="structTexture.html#ae1f2c7acab562a820bc75ab37f0db3c8">Texture::channels</a></div><div class="ttdeci">uint32_t channels</div><div class="ttdoc">number of channels of the texture</div><div class="ttdef"><b>Definition:</b> fwd.hpp:28</div></div>
<div class="ttc" id="astructMesh_html_abc59ae5bf8f9b8d5b806e6e91ae5e1f5"><div class="ttname"><a href="structMesh.html#abc59ae5bf8f9b8d5b806e6e91ae5e1f5">Mesh::normal</a></div><div class="ttdeci">VertexAttrib normal</div><div class="ttdoc">normal vertex attribute</div><div class="ttdef"><b>Definition:</b> fwd.hpp:235</div></div>
<div class="ttc" id="astructInVertex_html_a4fc269d49110daa41aedf9b8f313f0ca"><div class="ttname"><a href="structInVertex.html#a4fc269d49110daa41aedf9b8f313f0ca">InVertex::attributes</a></div><div class="ttdeci">Attribute attributes[maxAttributes]</div><div class="ttdoc">vertex attributes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:63</div></div>
<div class="ttc" id="afwd_8hpp_html_a2bfb0a0ff1c379a8b4e8f9d24fdd4839a17266551181f69a1b4a3ad5c9e270afc"><div class="ttname"><a href="fwd_8hpp.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839a17266551181f69a1b4a3ad5c9e270afc">IndexType::UINT32</a></div><div class="ttdeci">@ UINT32</div><div class="ttdoc">uint32_t type</div></div>
<div class="ttc" id="astructInFragment_html_af9cd9e9a684a1c454d52d7e191564be1"><div class="ttname"><a href="structInFragment.html#af9cd9e9a684a1c454d52d7e191564be1">InFragment::attributes</a></div><div class="ttdeci">Attribute attributes[maxAttributes]</div><div class="ttdoc">fragment attributes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:83</div></div>
<div class="ttc" id="astructFrame_html_a095a92799a36149100a0b95a936a4996"><div class="ttname"><a href="structFrame.html#a095a92799a36149100a0b95a936a4996">Frame::height</a></div><div class="ttdeci">uint32_t height</div><div class="ttdoc">height of frame</div><div class="ttdef"><b>Definition:</b> fwd.hpp:207</div></div>
<div class="ttc" id="aunionUniform_html_ae497d8a71600e5eb222cbcf8ad71788f"><div class="ttname"><a href="unionUniform.html#ae497d8a71600e5eb222cbcf8ad71788f">Uniform::v2</a></div><div class="ttdeci">glm::vec2 v2</div><div class="ttdoc">two floats</div><div class="ttdef"><b>Definition:</b> fwd.hpp:104</div></div>
<div class="ttc" id="astructInFragment_html_ae72e0b96e17181ea2cb2ef256e3f0a8f"><div class="ttname"><a href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">InFragment::gl_FragCoord</a></div><div class="ttdeci">glm::vec4 gl_FragCoord</div><div class="ttdoc">fragment coordinates</div><div class="ttdef"><b>Definition:</b> fwd.hpp:84</div></div>
<div class="ttc" id="astructVertexAttrib_html_a8a69adafb547d0991fa7031771b5771d"><div class="ttname"><a href="structVertexAttrib.html#a8a69adafb547d0991fa7031771b5771d">VertexAttrib::bufferData</a></div><div class="ttdeci">void const  * bufferData</div><div class="ttdoc">pointer to buffer</div><div class="ttdef"><b>Definition:</b> fwd.hpp:165</div></div>
<div class="ttc" id="aunionAttribute_html_a2a9e03282539207b21a9b61596e6b72c"><div class="ttname"><a href="unionAttribute.html#a2a9e03282539207b21a9b61596e6b72c">Attribute::v1</a></div><div class="ttdeci">float v1</div><div class="ttdoc">single float</div><div class="ttdef"><b>Definition:</b> fwd.hpp:51</div></div>
<div class="ttc" id="aunionAttribute_html"><div class="ttname"><a href="unionAttribute.html">Attribute</a></div><div class="ttdoc">[AttributeType]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:49</div></div>
<div class="ttc" id="aunionUniform_html_a70392e438c775c6213e6c2dec76b29c4"><div class="ttname"><a href="unionUniform.html#a70392e438c775c6213e6c2dec76b29c4">Uniform::v3</a></div><div class="ttdeci">glm::vec3 v3</div><div class="ttdoc">three floats</div><div class="ttdef"><b>Definition:</b> fwd.hpp:105</div></div>
<div class="ttc" id="astructInVertex_html"><div class="ttname"><a href="structInVertex.html">InVertex</a></div><div class="ttdoc">[Attribute]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:62</div></div>
<div class="ttc" id="afwd_8hpp_html_a2bfb0a0ff1c379a8b4e8f9d24fdd4839"><div class="ttname"><a href="fwd_8hpp.html#a2bfb0a0ff1c379a8b4e8f9d24fdd4839">IndexType</a></div><div class="ttdeci">IndexType</div><div class="ttdoc">[Uniforms]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:125</div></div>
<div class="ttc" id="aunionUniform_html_aec09b95ed538f79020d6e70323b27771"><div class="ttname"><a href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">Uniform::m4</a></div><div class="ttdeci">glm::mat4 m4</div><div class="ttdoc">4x4 float matrix</div><div class="ttdef"><b>Definition:</b> fwd.hpp:107</div></div>
<div class="ttc" id="astructModel_html"><div class="ttname"><a href="structModel.html">Model</a></div><div class="ttdoc">[Node]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:258</div></div>
<div class="ttc" id="astructMesh_html_a00f5a9d0221fc4e66dc165520a835460"><div class="ttname"><a href="structMesh.html#a00f5a9d0221fc4e66dc165520a835460">Mesh::position</a></div><div class="ttdeci">VertexAttrib position</div><div class="ttdoc">position vertex attribute</div><div class="ttdef"><b>Definition:</b> fwd.hpp:234</div></div>
<div class="ttc" id="astructMesh_html_a55de606f67f2aa169ef7b51042ade990"><div class="ttname"><a href="structMesh.html#a55de606f67f2aa169ef7b51042ade990">Mesh::indexType</a></div><div class="ttdeci">IndexType indexType</div><div class="ttdoc">type of indices</div><div class="ttdef"><b>Definition:</b> fwd.hpp:233</div></div>
<div class="ttc" id="afwd_8hpp_html_a349a9cde14be8097df865ba0469c0ab2aba2b45bdc11e2a4a6e86aab2ac693cbb"><div class="ttname"><a href="fwd_8hpp.html#a349a9cde14be8097df865ba0469c0ab2aba2b45bdc11e2a4a6e86aab2ac693cbb">AttributeType::EMPTY</a></div><div class="ttdeci">@ EMPTY</div><div class="ttdoc">disabled attribute</div></div>
<div class="ttc" id="astructNode_html_a825a38e1f0d49fcc1a0cdbad46473bf2"><div class="ttname"><a href="structNode.html#a825a38e1f0d49fcc1a0cdbad46473bf2">Node::modelMatrix</a></div><div class="ttdeci">glm::mat4 modelMatrix</div><div class="ttdoc">model transformation matrix</div><div class="ttdef"><b>Definition:</b> fwd.hpp:248</div></div>
<div class="ttc" id="astructFrame_html_a3b9db2c521a7553301b61c7c72da513a"><div class="ttname"><a href="structFrame.html#a3b9db2c521a7553301b61c7c72da513a">Frame::depth</a></div><div class="ttdeci">float * depth</div><div class="ttdoc">depth buffer</div><div class="ttdef"><b>Definition:</b> fwd.hpp:205</div></div>
<div class="ttc" id="afwd_8hpp_html_a349a9cde14be8097df865ba0469c0ab2"><div class="ttname"><a href="fwd_8hpp.html#a349a9cde14be8097df865ba0469c0ab2">AttributeType</a></div><div class="ttdeci">AttributeType</div><div class="ttdoc">[Texture]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:36</div></div>
<div class="ttc" id="astructNode_html_af7ddc81358470c3bf7a7819c8b77f53d"><div class="ttname"><a href="structNode.html#af7ddc81358470c3bf7a7819c8b77f53d">Node::children</a></div><div class="ttdeci">std::vector&lt; Node &gt; children</div><div class="ttdoc">list of children nodes</div><div class="ttdef"><b>Definition:</b> fwd.hpp:250</div></div>
<div class="ttc" id="astructOutFragment_html"><div class="ttname"><a href="structOutFragment.html">OutFragment</a></div><div class="ttdoc">[InFragment]</div><div class="ttdef"><b>Definition:</b> fwd.hpp:92</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 15 2021 12:57:49 for Izg project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
